Subject: [PATCH] QCXR
---
Index: build.gradle
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/build.gradle b/build.gradle
--- a/build.gradle	(revision eaec65274edbf6dec8d28b76e7403b21c6b3145b)
+++ b/build.gradle	(revision a1131575d6931b12d3cb0b9f8a519b861bc5ca4c)
@@ -31,6 +31,11 @@
         implementation("org.lwjgl:lwjgl-openvr:3.3.2:natives-linux")
         implementation("org.lwjgl:lwjgl-openvr:3.3.2:natives-macos")
         implementation("org.lwjgl:lwjgl-openvr:3.3.2:natives-windows")
+
+        implementation("org.lwjgl:lwjgl-openxr:3.3.1")
+        implementation("org.lwjgl:lwjgl-openxr:3.3.1:natives-linux")
+        //implementation("org.lwjgl:lwjgl-openxr:3.3.1:natives-macos")
+        implementation("org.lwjgl:lwjgl-openxr:3.3.1:natives-windows")
     }
 
     tasks.withType(JavaCompile) {
Index: common/src/main/java/org/lwjgl/openxr/KHRAndroidCreateInstance.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/src/main/java/org/lwjgl/openxr/KHRAndroidCreateInstance.java b/common/src/main/java/org/lwjgl/openxr/KHRAndroidCreateInstance.java
new file mode 100644
--- /dev/null	(revision a1131575d6931b12d3cb0b9f8a519b861bc5ca4c)
+++ b/common/src/main/java/org/lwjgl/openxr/KHRAndroidCreateInstance.java	(revision a1131575d6931b12d3cb0b9f8a519b861bc5ca4c)
@@ -0,0 +1,23 @@
+/*
+ * Copyright LWJGL. All rights reserved.
+ * License terms: https://www.lwjgl.org/license
+ * MACHINE GENERATED FILE, DO NOT EDIT
+ */
+package org.lwjgl.openxr;
+
+import org.jetbrains.annotations.Nullable;
+/** The KHR_android_create_instance extension. */
+public final class KHRAndroidCreateInstance {
+
+    /** The extension specification version. */
+    public static final int XR_KHR_android_create_instance_SPEC_VERSION = 3;
+
+    /** The extension name. */
+    public static final String XR_KHR_ANDROID_CREATE_INSTANCE_EXTENSION_NAME = "XR_KHR_android_create_instance";
+
+    /** Extends {@code XrStructureType}. */
+    public static final int XR_TYPE_INSTANCE_CREATE_INFO_ANDROID_KHR = 1000008000;
+
+    private KHRAndroidCreateInstance() {}
+
+}
\ No newline at end of file
Index: common/src/main/java/org/lwjgl/openxr/XrGraphicsBindingOpenGLESAndroidKHR.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/src/main/java/org/lwjgl/openxr/XrGraphicsBindingOpenGLESAndroidKHR.java b/common/src/main/java/org/lwjgl/openxr/XrGraphicsBindingOpenGLESAndroidKHR.java
new file mode 100644
--- /dev/null	(revision a1131575d6931b12d3cb0b9f8a519b861bc5ca4c)
+++ b/common/src/main/java/org/lwjgl/openxr/XrGraphicsBindingOpenGLESAndroidKHR.java	(revision a1131575d6931b12d3cb0b9f8a519b861bc5ca4c)
@@ -0,0 +1,396 @@
+/*
+ * Copyright LWJGL. All rights reserved.
+ * License terms: https://www.lwjgl.org/license
+ * MACHINE GENERATED FILE, DO NOT EDIT
+ */
+package org.lwjgl.openxr;
+
+import javax.annotation.*;
+
+import java.nio.*;
+
+import org.lwjgl.*;
+import org.lwjgl.BufferUtils;
+import org.lwjgl.system.*;
+import org.lwjgl.system.MemoryStack;
+import org.lwjgl.system.NativeResource;
+import org.lwjgl.system.NativeType;
+import org.lwjgl.system.Struct;
+import org.lwjgl.system.StructBuffer;
+
+import static org.lwjgl.system.Checks.*;
+import static org.lwjgl.system.MemoryUtil.*;
+import static org.lwjgl.system.MemoryStack.*;
+
+/**
+ * <h3>Layout</h3>
+ * 
+ * <pre><code>
+ * struct XrGraphicsBindingOpenGLESAndroidKHR {
+ *     XrStructureType type;
+ *     void const * next;
+ *     EGLDisplay display;
+ *     EGLConfig config;
+ *     EGLContext context;
+ * }</code></pre>
+ */
+public class XrGraphicsBindingOpenGLESAndroidKHR extends Struct implements NativeResource {
+
+    /** The struct size in bytes. */
+    public static final int SIZEOF;
+
+    /** The struct alignment in bytes. */
+    public static final int ALIGNOF;
+
+    /** The struct member offsets. */
+    public static final int
+        TYPE,
+        NEXT,
+        DISPLAY,
+        CONFIG,
+        CONTEXT;
+
+    static {
+        Layout layout = __struct(
+            __member(4),
+            __member(POINTER_SIZE),
+            __member(POINTER_SIZE),
+            __member(POINTER_SIZE),
+            __member(POINTER_SIZE)
+        );
+
+        SIZEOF = layout.getSize();
+        ALIGNOF = layout.getAlignment();
+
+        TYPE = layout.offsetof(0);
+        NEXT = layout.offsetof(1);
+        DISPLAY = layout.offsetof(2);
+        CONFIG = layout.offsetof(3);
+        CONTEXT = layout.offsetof(4);
+    }
+
+    /**
+     * Creates a {@code XrGraphicsBindingOpenGLESAndroidKHR} instance at the current position of the specified {@link ByteBuffer} container. Changes to the buffer's content will be
+     * visible to the struct instance and vice versa.
+     *
+     * <p>The created instance holds a strong reference to the container object.</p>
+     */
+    public XrGraphicsBindingOpenGLESAndroidKHR(ByteBuffer container) {
+        super(memAddress(container), __checkContainer(container, SIZEOF));
+    }
+
+    @Override
+    public int sizeof() { return SIZEOF; }
+
+    /** @return the value of the {@code type} field. */
+    @NativeType("XrStructureType")
+    public int type() { return ntype(address()); }
+    /** @return the value of the {@code next} field. */
+    @NativeType("void const *")
+    public long next() { return nnext(address()); }
+    /** @return the value of the {@code display} field. */
+    @NativeType("EGLDisplay")
+    public long display() { return ndisplay(address()); }
+    /** @return the value of the {@code config} field. */
+    @NativeType("EGLConfig")
+    public long config() { return nconfig(address()); }
+    /** @return the value of the {@code context} field. */
+    @NativeType("EGLContext")
+    public long context() { return ncontext(address()); }
+
+    /** Sets the specified value to the {@code type} field. */
+    public XrGraphicsBindingOpenGLESAndroidKHR type(@NativeType("XrStructureType") int value) { ntype(address(), value); return this; }
+    /** Sets the specified value to the {@code next} field. */
+    public XrGraphicsBindingOpenGLESAndroidKHR next(@NativeType("void const *") long value) { nnext(address(), value); return this; }
+    /** Sets the specified value to the {@code display} field. */
+    public XrGraphicsBindingOpenGLESAndroidKHR display(@NativeType("EGLDisplay") long value) { ndisplay(address(), value); return this; }
+    /** Sets the specified value to the {@code config} field. */
+    public XrGraphicsBindingOpenGLESAndroidKHR config(@NativeType("EGLConfig") long value) { nconfig(address(), value); return this; }
+    /** Sets the specified value to the {@code context} field. */
+    public XrGraphicsBindingOpenGLESAndroidKHR context(@NativeType("EGLContext") long value) { ncontext(address(), value); return this; }
+
+    /** Initializes this struct with the specified values. */
+    public XrGraphicsBindingOpenGLESAndroidKHR set(
+        int type,
+        long next,
+        long display,
+        long config,
+        long context
+    ) {
+        type(type);
+        next(next);
+        display(display);
+        config(config);
+        context(context);
+
+        return this;
+    }
+
+    /**
+     * Copies the specified struct data to this struct.
+     *
+     * @param src the source struct
+     *
+     * @return this struct
+     */
+    public XrGraphicsBindingOpenGLESAndroidKHR set(XrGraphicsBindingOpenGLESAndroidKHR src) {
+        memCopy(src.address(), address(), SIZEOF);
+        return this;
+    }
+
+    // -----------------------------------
+
+    /** Returns a new {@code XrGraphicsBindingOpenGLESAndroidKHR} instance allocated with {@link MemoryUtil#memAlloc memAlloc}. The instance must be explicitly freed. */
+    public static XrGraphicsBindingOpenGLESAndroidKHR malloc() {
+        return wrap(XrGraphicsBindingOpenGLESAndroidKHR.class, nmemAllocChecked(SIZEOF));
+    }
+
+    /** Returns a new {@code XrGraphicsBindingOpenGLESAndroidKHR} instance allocated with {@link MemoryUtil#memCalloc memCalloc}. The instance must be explicitly freed. */
+    public static XrGraphicsBindingOpenGLESAndroidKHR calloc() {
+        return wrap(XrGraphicsBindingOpenGLESAndroidKHR.class, nmemCallocChecked(1, SIZEOF));
+    }
+
+    /** Returns a new {@code XrGraphicsBindingOpenGLESAndroidKHR} instance allocated with {@link BufferUtils}. */
+    public static XrGraphicsBindingOpenGLESAndroidKHR create() {
+        ByteBuffer container = BufferUtils.createByteBuffer(SIZEOF);
+        return wrap(XrGraphicsBindingOpenGLESAndroidKHR.class, memAddress(container), container);
+    }
+
+    /** Returns a new {@code XrGraphicsBindingOpenGLESAndroidKHR} instance for the specified memory address. */
+    public static XrGraphicsBindingOpenGLESAndroidKHR create(long address) {
+        return wrap(XrGraphicsBindingOpenGLESAndroidKHR.class, address);
+    }
+
+    /** Like {@link #create(long) create}, but returns {@code null} if {@code address} is {@code NULL}. */
+    @Nullable
+    public static XrGraphicsBindingOpenGLESAndroidKHR createSafe(long address) {
+        return address == NULL ? null : wrap(XrGraphicsBindingOpenGLESAndroidKHR.class, address);
+    }
+
+    /**
+     * Returns a new {@link Buffer} instance allocated with {@link MemoryUtil#memAlloc memAlloc}. The instance must be explicitly freed.
+     *
+     * @param capacity the buffer capacity
+     */
+    public static Buffer malloc(int capacity) {
+        return wrap(Buffer.class, nmemAllocChecked(__checkMalloc(capacity, SIZEOF)), capacity);
+    }
+
+    /**
+     * Returns a new {@link Buffer} instance allocated with {@link MemoryUtil#memCalloc memCalloc}. The instance must be explicitly freed.
+     *
+     * @param capacity the buffer capacity
+     */
+    public static Buffer calloc(int capacity) {
+        return wrap(Buffer.class, nmemCallocChecked(capacity, SIZEOF), capacity);
+    }
+
+    /**
+     * Returns a new {@link Buffer} instance allocated with {@link BufferUtils}.
+     *
+     * @param capacity the buffer capacity
+     */
+    public static Buffer create(int capacity) {
+        ByteBuffer container = __create(capacity, SIZEOF);
+        return wrap(Buffer.class, memAddress(container), capacity, container);
+    }
+
+    /**
+     * Create a {@link Buffer} instance at the specified memory.
+     *
+     * @param address  the memory address
+     * @param capacity the buffer capacity
+     */
+    public static Buffer create(long address, int capacity) {
+        return wrap(Buffer.class, address, capacity);
+    }
+
+    /** Like {@link #create(long, int) create}, but returns {@code null} if {@code address} is {@code NULL}. */
+    @Nullable
+    public static Buffer createSafe(long address, int capacity) {
+        return address == NULL ? null : wrap(Buffer.class, address, capacity);
+    }
+
+    // -----------------------------------
+
+    /** Returns a new {@code XrGraphicsBindingOpenGLESAndroidKHR} instance allocated on the thread-local {@link MemoryStack}. */
+    public static XrGraphicsBindingOpenGLESAndroidKHR mallocStack() {
+        return mallocStack(stackGet());
+    }
+
+    /** Returns a new {@code XrGraphicsBindingOpenGLESAndroidKHR} instance allocated on the thread-local {@link MemoryStack} and initializes all its bits to zero. */
+    public static XrGraphicsBindingOpenGLESAndroidKHR callocStack() {
+        return callocStack(stackGet());
+    }
+
+    /**
+     * Returns a new {@code XrGraphicsBindingOpenGLESAndroidKHR} instance allocated on the specified {@link MemoryStack}.
+     *
+     * @param stack the stack from which to allocate
+     */
+    public static XrGraphicsBindingOpenGLESAndroidKHR mallocStack(MemoryStack stack) {
+        return wrap(XrGraphicsBindingOpenGLESAndroidKHR.class, stack.nmalloc(ALIGNOF, SIZEOF));
+    }
+
+    /**
+     * Returns a new {@code XrGraphicsBindingOpenGLESAndroidKHR} instance allocated on the specified {@link MemoryStack} and initializes all its bits to zero.
+     *
+     * @param stack the stack from which to allocate
+     */
+    public static XrGraphicsBindingOpenGLESAndroidKHR callocStack(MemoryStack stack) {
+        return wrap(XrGraphicsBindingOpenGLESAndroidKHR.class, stack.ncalloc(ALIGNOF, 1, SIZEOF));
+    }
+
+    /**
+     * Returns a new {@link Buffer} instance allocated on the thread-local {@link MemoryStack}.
+     *
+     * @param capacity the buffer capacity
+     */
+    public static Buffer mallocStack(int capacity) {
+        return mallocStack(capacity, stackGet());
+    }
+
+    /**
+     * Returns a new {@link Buffer} instance allocated on the thread-local {@link MemoryStack} and initializes all its bits to zero.
+     *
+     * @param capacity the buffer capacity
+     */
+    public static Buffer callocStack(int capacity) {
+        return callocStack(capacity, stackGet());
+    }
+
+    /**
+     * Returns a new {@link Buffer} instance allocated on the specified {@link MemoryStack}.
+     *
+     * @param stack the stack from which to allocate
+     * @param capacity the buffer capacity
+     */
+    public static Buffer mallocStack(int capacity, MemoryStack stack) {
+        return wrap(Buffer.class, stack.nmalloc(ALIGNOF, capacity * SIZEOF), capacity);
+    }
+
+    /**
+     * Returns a new {@link Buffer} instance allocated on the specified {@link MemoryStack} and initializes all its bits to zero.
+     *
+     * @param stack the stack from which to allocate
+     * @param capacity the buffer capacity
+     */
+    public static Buffer callocStack(int capacity, MemoryStack stack) {
+        return wrap(Buffer.class, stack.ncalloc(ALIGNOF, capacity, SIZEOF), capacity);
+    }
+
+    // -----------------------------------
+
+    /** Unsafe version of {@link #type}. */
+    public static int ntype(long struct) { return UNSAFE.getInt(null, struct + XrGraphicsBindingOpenGLESAndroidKHR.TYPE); }
+    /** Unsafe version of {@link #next}. */
+    public static long nnext(long struct) { return memGetAddress(struct + XrGraphicsBindingOpenGLESAndroidKHR.NEXT); }
+    /** Unsafe version of {@link #display}. */
+    public static long ndisplay(long struct) { return memGetAddress(struct + XrGraphicsBindingOpenGLESAndroidKHR.DISPLAY); }
+    /** Unsafe version of {@link #config}. */
+    public static long nconfig(long struct) { return memGetAddress(struct + XrGraphicsBindingOpenGLESAndroidKHR.CONFIG); }
+    /** Unsafe version of {@link #context}. */
+    public static long ncontext(long struct) { return memGetAddress(struct + XrGraphicsBindingOpenGLESAndroidKHR.CONTEXT); }
+
+    /** Unsafe version of {@link #type(int) type}. */
+    public static void ntype(long struct, int value) { UNSAFE.putInt(null, struct + XrGraphicsBindingOpenGLESAndroidKHR.TYPE, value); }
+    /** Unsafe version of {@link #next(long) next}. */
+    public static void nnext(long struct, long value) { memPutAddress(struct + XrGraphicsBindingOpenGLESAndroidKHR.NEXT, value); }
+    /** Unsafe version of {@link #display(long) display}. */
+    public static void ndisplay(long struct, long value) { memPutAddress(struct + XrGraphicsBindingOpenGLESAndroidKHR.DISPLAY, check(value)); }
+    /** Unsafe version of {@link #config(long) config}. */
+    public static void nconfig(long struct, long value) { memPutAddress(struct + XrGraphicsBindingOpenGLESAndroidKHR.CONFIG, check(value)); }
+    /** Unsafe version of {@link #context(long) context}. */
+    public static void ncontext(long struct, long value) { memPutAddress(struct + XrGraphicsBindingOpenGLESAndroidKHR.CONTEXT, check(value)); }
+
+    /**
+     * Validates pointer members that should not be {@code NULL}.
+     *
+     * @param struct the struct to validate
+     */
+    public static void validate(long struct) {
+        check(memGetAddress(struct + XrGraphicsBindingOpenGLESAndroidKHR.DISPLAY));
+        check(memGetAddress(struct + XrGraphicsBindingOpenGLESAndroidKHR.CONFIG));
+        check(memGetAddress(struct + XrGraphicsBindingOpenGLESAndroidKHR.CONTEXT));
+    }
+
+    /**
+     * Calls {@link #validate(long)} for each struct contained in the specified struct array.
+     *
+     * @param array the struct array to validate
+     * @param count the number of structs in {@code array}
+     */
+    public static void validate(long array, int count) {
+        for (int i = 0; i < count; i++) {
+            validate(array + Integer.toUnsignedLong(i) * SIZEOF);
+        }
+    }
+
+    // -----------------------------------
+
+    /** An array of {@link XrGraphicsBindingOpenGLESAndroidKHR} structs. */
+    public static class Buffer extends StructBuffer<XrGraphicsBindingOpenGLESAndroidKHR, Buffer> implements NativeResource {
+
+        private static final XrGraphicsBindingOpenGLESAndroidKHR ELEMENT_FACTORY = XrGraphicsBindingOpenGLESAndroidKHR.create(-1L);
+
+        /**
+         * Creates a new {@code XrGraphicsBindingOpenGLESAndroidKHR.Buffer} instance backed by the specified container.
+         *
+         * Changes to the container's content will be visible to the struct buffer instance and vice versa. The two buffers' position, limit, and mark values
+         * will be independent. The new buffer's position will be zero, its capacity and its limit will be the number of bytes remaining in this buffer divided
+         * by {@link XrGraphicsBindingOpenGLESAndroidKHR#SIZEOF}, and its mark will be undefined.
+         *
+         * <p>The created buffer instance holds a strong reference to the container object.</p>
+         */
+        public Buffer(ByteBuffer container) {
+            super(container, container.remaining() / SIZEOF);
+        }
+
+        public Buffer(long address, int cap) {
+            super(address, null, -1, 0, cap, cap);
+        }
+
+        Buffer(long address, @Nullable ByteBuffer container, int mark, int pos, int lim, int cap) {
+            super(address, container, mark, pos, lim, cap);
+        }
+
+        @Override
+        protected Buffer self() {
+            return this;
+        }
+
+        @Override
+        protected XrGraphicsBindingOpenGLESAndroidKHR getElementFactory() {
+            return ELEMENT_FACTORY;
+        }
+
+        /** @return the value of the {@code type} field. */
+        @NativeType("XrStructureType")
+        public int type() { return XrGraphicsBindingOpenGLESAndroidKHR.ntype(address()); }
+        /** @return the value of the {@code next} field. */
+        @NativeType("void const *")
+        public long next() { return XrGraphicsBindingOpenGLESAndroidKHR.nnext(address()); }
+        /** @return the value of the {@code display} field. */
+        @NativeType("EGLDisplay")
+        public long display() { return XrGraphicsBindingOpenGLESAndroidKHR.ndisplay(address()); }
+        /** @return the value of the {@code config} field. */
+        @NativeType("EGLConfig")
+        public long config() { return XrGraphicsBindingOpenGLESAndroidKHR.nconfig(address()); }
+        /** @return the value of the {@code context} field. */
+        @NativeType("EGLContext")
+        public long context() { return XrGraphicsBindingOpenGLESAndroidKHR.ncontext(address()); }
+
+        /** Sets the specified value to the {@code type} field. */
+        public Buffer type(@NativeType("XrStructureType") int value) { XrGraphicsBindingOpenGLESAndroidKHR.ntype(address(), value); return this; }
+        /** Sets the specified value to the {@code next} field. */
+        public Buffer next(@NativeType("void const *") long value) { XrGraphicsBindingOpenGLESAndroidKHR.nnext(address(), value); return this; }
+        /** Sets the specified value to the {@code display} field. */
+        public Buffer display(@NativeType("EGLDisplay") long value) { XrGraphicsBindingOpenGLESAndroidKHR.ndisplay(address(), value); return this; }
+        /** Sets the specified value to the {@code config} field. */
+        public Buffer config(@NativeType("EGLConfig") long value) { XrGraphicsBindingOpenGLESAndroidKHR.nconfig(address(), value); return this; }
+        /** Sets the specified value to the {@code context} field. */
+        public Buffer context(@NativeType("EGLContext") long value) { XrGraphicsBindingOpenGLESAndroidKHR.ncontext(address(), value); return this; }
+
+    }
+
+}
Index: common/src/main/java/org/lwjgl/openxr/XrInstanceCreateInfoAndroidKHR.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/src/main/java/org/lwjgl/openxr/XrInstanceCreateInfoAndroidKHR.java b/common/src/main/java/org/lwjgl/openxr/XrInstanceCreateInfoAndroidKHR.java
new file mode 100644
--- /dev/null	(revision a1131575d6931b12d3cb0b9f8a519b861bc5ca4c)
+++ b/common/src/main/java/org/lwjgl/openxr/XrInstanceCreateInfoAndroidKHR.java	(revision a1131575d6931b12d3cb0b9f8a519b861bc5ca4c)
@@ -0,0 +1,347 @@
+/*
+ * Copyright LWJGL. All rights reserved.
+ * License terms: https://www.lwjgl.org/license
+ * MACHINE GENERATED FILE, DO NOT EDIT
+ */
+package org.lwjgl.openxr;
+
+import org.jetbrains.annotations.Nullable;
+import org.lwjgl.BufferUtils;
+import org.lwjgl.system.*;
+import org.lwjgl.system.MemoryStack;
+import org.lwjgl.system.NativeResource;
+import org.lwjgl.system.NativeType;
+import org.lwjgl.system.Struct;
+import org.lwjgl.system.StructBuffer;
+
+import java.nio.ByteBuffer;
+
+import static org.lwjgl.system.Checks.check;
+import static org.lwjgl.system.MemoryUtil.*;
+
+/**
+ * <h3>Layout</h3>
+ * 
+ * <pre><code>
+ * struct XrInstanceCreateInfoAndroidKHR {
+ *     XrStructureType type;
+ *     void const * next;
+ *     void * applicationVM;
+ *     void * applicationActivity;
+ * }</code></pre>
+ */
+public class XrInstanceCreateInfoAndroidKHR extends Struct implements NativeResource {
+
+    /** The struct size in bytes. */
+    public static final int SIZEOF;
+
+    /** The struct alignment in bytes. */
+    public static final int ALIGNOF;
+
+    /** The struct member offsets. */
+    public static final int
+        TYPE,
+        NEXT,
+        APPLICATIONVM,
+        APPLICATIONACTIVITY;
+
+    static {
+        Layout layout = __struct(
+            __member(4),
+            __member(POINTER_SIZE),
+            __member(POINTER_SIZE),
+            __member(POINTER_SIZE)
+        );
+
+        SIZEOF = layout.getSize();
+        ALIGNOF = layout.getAlignment();
+
+        TYPE = layout.offsetof(0);
+        NEXT = layout.offsetof(1);
+        APPLICATIONVM = layout.offsetof(2);
+        APPLICATIONACTIVITY = layout.offsetof(3);
+    }
+
+    /**
+     * Creates a {@code XrInstanceCreateInfoAndroidKHR} instance at the current position of the specified {@link ByteBuffer} container. Changes to the buffer's content will be
+     * visible to the struct instance and vice versa.
+     *
+     * <p>The created instance holds a strong reference to the container object.</p>
+     */
+    public XrInstanceCreateInfoAndroidKHR(ByteBuffer container) {
+        super(memAddress(container), __checkContainer(container, SIZEOF));
+    }
+
+    @Override
+    public int sizeof() { return SIZEOF; }
+
+    /** @return the value of the {@code type} field. */
+    @NativeType("XrStructureType")
+    public int type() { return ntype(address()); }
+    /** @return the value of the {@code next} field. */
+    @NativeType("void const *")
+    public long next() { return nnext(address()); }
+    /** @return the value of the {@code applicationVM} field. */
+    @NativeType("void *")
+    public long applicationVM() { return napplicationVM(address()); }
+    /** @return the value of the {@code applicationActivity} field. */
+    @NativeType("void *")
+    public long applicationActivity() { return napplicationActivity(address()); }
+
+    /** Sets the specified value to the {@code type} field. */
+    public XrInstanceCreateInfoAndroidKHR type(@NativeType("XrStructureType") int value) { ntype(address(), value); return this; }
+    /** Sets the {@link KHRAndroidCreateInstance#XR_TYPE_INSTANCE_CREATE_INFO_ANDROID_KHR TYPE_INSTANCE_CREATE_INFO_ANDROID_KHR} value to the {@code type} field. */
+    public XrInstanceCreateInfoAndroidKHR type$Default() { return type(KHRAndroidCreateInstance.XR_TYPE_INSTANCE_CREATE_INFO_ANDROID_KHR); }
+    /** Sets the specified value to the {@code next} field. */
+    public XrInstanceCreateInfoAndroidKHR next(@NativeType("void const *") long value) { nnext(address(), value); return this; }
+    /** Sets the specified value to the {@code applicationVM} field. */
+    public XrInstanceCreateInfoAndroidKHR applicationVM(@NativeType("void *") long value) { napplicationVM(address(), value); return this; }
+    /** Sets the specified value to the {@code applicationActivity} field. */
+    public XrInstanceCreateInfoAndroidKHR applicationActivity(@NativeType("void *") long value) { napplicationActivity(address(), value); return this; }
+
+    /** Initializes this struct with the specified values. */
+    public XrInstanceCreateInfoAndroidKHR set(
+        int type,
+        long next,
+        long applicationVM,
+        long applicationActivity
+    ) {
+        type(type);
+        next(next);
+        applicationVM(applicationVM);
+        applicationActivity(applicationActivity);
+
+        return this;
+    }
+
+    /**
+     * Copies the specified struct data to this struct.
+     *
+     * @param src the source struct
+     *
+     * @return this struct
+     */
+    public XrInstanceCreateInfoAndroidKHR set(XrInstanceCreateInfoAndroidKHR src) {
+        memCopy(src.address(), address(), SIZEOF);
+        return this;
+    }
+
+    // -----------------------------------
+
+    /** Returns a new {@code XrInstanceCreateInfoAndroidKHR} instance allocated with {@link MemoryUtil#memAlloc memAlloc}. The instance must be explicitly freed. */
+    public static XrInstanceCreateInfoAndroidKHR malloc() {
+        return wrap(XrInstanceCreateInfoAndroidKHR.class, nmemAllocChecked(SIZEOF));
+    }
+
+    /** Returns a new {@code XrInstanceCreateInfoAndroidKHR} instance allocated with {@link MemoryUtil#memCalloc memCalloc}. The instance must be explicitly freed. */
+    public static XrInstanceCreateInfoAndroidKHR calloc() {
+        return wrap(XrInstanceCreateInfoAndroidKHR.class, nmemCallocChecked(1, SIZEOF));
+    }
+
+    /** Returns a new {@code XrInstanceCreateInfoAndroidKHR} instance allocated with {@link BufferUtils}. */
+    public static XrInstanceCreateInfoAndroidKHR create() {
+        ByteBuffer container = BufferUtils.createByteBuffer(SIZEOF);
+        return wrap(XrInstanceCreateInfoAndroidKHR.class, memAddress(container), container);
+    }
+
+    /** Returns a new {@code XrInstanceCreateInfoAndroidKHR} instance for the specified memory address. */
+    public static XrInstanceCreateInfoAndroidKHR create(long address) {
+        return wrap(XrInstanceCreateInfoAndroidKHR.class, address);
+    }
+
+    /** Like {@link #create(long) create}, but returns {@code null} if {@code address} is {@code NULL}. */
+    @Nullable
+    public static XrInstanceCreateInfoAndroidKHR createSafe(long address) {
+        return address == NULL ? null : wrap(XrInstanceCreateInfoAndroidKHR.class, address);
+    }
+
+    /**
+     * Returns a new {@link Buffer} instance allocated with {@link MemoryUtil#memAlloc memAlloc}. The instance must be explicitly freed.
+     *
+     * @param capacity the buffer capacity
+     */
+    public static Buffer malloc(int capacity) {
+        return wrap(Buffer.class, nmemAllocChecked(__checkMalloc(capacity, SIZEOF)), capacity);
+    }
+
+    /**
+     * Returns a new {@link Buffer} instance allocated with {@link MemoryUtil#memCalloc memCalloc}. The instance must be explicitly freed.
+     *
+     * @param capacity the buffer capacity
+     */
+    public static Buffer calloc(int capacity) {
+        return wrap(Buffer.class, nmemCallocChecked(capacity, SIZEOF), capacity);
+    }
+
+    /**
+     * Returns a new {@link Buffer} instance allocated with {@link BufferUtils}.
+     *
+     * @param capacity the buffer capacity
+     */
+    public static Buffer create(int capacity) {
+        ByteBuffer container = __create(capacity, SIZEOF);
+        return wrap(Buffer.class, memAddress(container), capacity, container);
+    }
+
+    /**
+     * Create a {@link Buffer} instance at the specified memory.
+     *
+     * @param address  the memory address
+     * @param capacity the buffer capacity
+     */
+    public static Buffer create(long address, int capacity) {
+        return wrap(Buffer.class, address, capacity);
+    }
+
+    /** Like {@link #create(long, int) create}, but returns {@code null} if {@code address} is {@code NULL}. */
+    @Nullable
+    public static XrInstanceCreateInfoAndroidKHR.Buffer createSafe(long address, int capacity) {
+        return address == NULL ? null : wrap(Buffer.class, address, capacity);
+    }
+
+
+    /**
+     * Returns a new {@code XrInstanceCreateInfoAndroidKHR} instance allocated on the specified {@link MemoryStack}.
+     *
+     * @param stack the stack from which to allocate
+     */
+    public static XrInstanceCreateInfoAndroidKHR malloc(MemoryStack stack) {
+        return wrap(XrInstanceCreateInfoAndroidKHR.class, stack.nmalloc(ALIGNOF, SIZEOF));
+    }
+
+    /**
+     * Returns a new {@code XrInstanceCreateInfoAndroidKHR} instance allocated on the specified {@link MemoryStack} and initializes all its bits to zero.
+     *
+     * @param stack the stack from which to allocate
+     */
+    public static XrInstanceCreateInfoAndroidKHR calloc(MemoryStack stack) {
+        return wrap(XrInstanceCreateInfoAndroidKHR.class, stack.ncalloc(ALIGNOF, 1, SIZEOF));
+    }
+
+    /**
+     * Returns a new {@link Buffer} instance allocated on the specified {@link MemoryStack}.
+     *
+     * @param stack    the stack from which to allocate
+     * @param capacity the buffer capacity
+     */
+    public static Buffer malloc(int capacity, MemoryStack stack) {
+        return wrap(Buffer.class, stack.nmalloc(ALIGNOF, capacity * SIZEOF), capacity);
+    }
+
+    /**
+     * Returns a new {@link Buffer} instance allocated on the specified {@link MemoryStack} and initializes all its bits to zero.
+     *
+     * @param stack    the stack from which to allocate
+     * @param capacity the buffer capacity
+     */
+    public static Buffer calloc(int capacity, MemoryStack stack) {
+        return wrap(Buffer.class, stack.ncalloc(ALIGNOF, capacity, SIZEOF), capacity);
+    }
+
+    // -----------------------------------
+
+    /** Unsafe version of {@link #type}. */
+    public static int ntype(long struct) { return UNSAFE.getInt(null, struct + XrInstanceCreateInfoAndroidKHR.TYPE); }
+    /** Unsafe version of {@link #next}. */
+    public static long nnext(long struct) { return memGetAddress(struct + XrInstanceCreateInfoAndroidKHR.NEXT); }
+    /** Unsafe version of {@link #applicationVM}. */
+    public static long napplicationVM(long struct) { return memGetAddress(struct + XrInstanceCreateInfoAndroidKHR.APPLICATIONVM); }
+    /** Unsafe version of {@link #applicationActivity}. */
+    public static long napplicationActivity(long struct) { return memGetAddress(struct + XrInstanceCreateInfoAndroidKHR.APPLICATIONACTIVITY); }
+
+    /** Unsafe version of {@link #type(int) type}. */
+    public static void ntype(long struct, int value) { UNSAFE.putInt(null, struct + XrInstanceCreateInfoAndroidKHR.TYPE, value); }
+    /** Unsafe version of {@link #next(long) next}. */
+    public static void nnext(long struct, long value) { memPutAddress(struct + XrInstanceCreateInfoAndroidKHR.NEXT, value); }
+    /** Unsafe version of {@link #applicationVM(long) applicationVM}. */
+    public static void napplicationVM(long struct, long value) { memPutAddress(struct + XrInstanceCreateInfoAndroidKHR.APPLICATIONVM, check(value)); }
+    /** Unsafe version of {@link #applicationActivity(long) applicationActivity}. */
+    public static void napplicationActivity(long struct, long value) { memPutAddress(struct + XrInstanceCreateInfoAndroidKHR.APPLICATIONACTIVITY, check(value)); }
+
+    /**
+     * Validates pointer members that should not be {@code NULL}.
+     *
+     * @param struct the struct to validate
+     */
+    public static void validate(long struct) {
+        check(memGetAddress(struct + XrInstanceCreateInfoAndroidKHR.APPLICATIONVM));
+        check(memGetAddress(struct + XrInstanceCreateInfoAndroidKHR.APPLICATIONACTIVITY));
+    }
+
+    /**
+     * Calls {@link #validate(long)} for each struct contained in the specified struct array.
+     *
+     * @param array the struct array to validate
+     * @param count the number of structs in {@code array}
+     */
+    public static void validate(long array, int count) {
+        for (int i = 0; i < count; i++) {
+            validate(array + Integer.toUnsignedLong(i) * SIZEOF);
+        }
+    }
+
+    // -----------------------------------
+
+    /** An array of {@link XrInstanceCreateInfoAndroidKHR} structs. */
+    public static class Buffer extends StructBuffer<XrInstanceCreateInfoAndroidKHR, Buffer> implements NativeResource {
+
+        private static final XrInstanceCreateInfoAndroidKHR ELEMENT_FACTORY = XrInstanceCreateInfoAndroidKHR.create(-1L);
+
+        /**
+         * Creates a new {@code XrInstanceCreateInfoAndroidKHR.Buffer} instance backed by the specified container.
+         *
+         * Changes to the container's content will be visible to the struct buffer instance and vice versa. The two buffers' position, limit, and mark values
+         * will be independent. The new buffer's position will be zero, its capacity and its limit will be the number of bytes remaining in this buffer divided
+         * by {@link XrInstanceCreateInfoAndroidKHR#SIZEOF}, and its mark will be undefined.
+         *
+         * <p>The created buffer instance holds a strong reference to the container object.</p>
+         */
+        public Buffer(ByteBuffer container) {
+            super(container, container.remaining() / SIZEOF);
+        }
+
+        public Buffer(long address, int cap) {
+            super(address, null, -1, 0, cap, cap);
+        }
+
+        Buffer(long address, @Nullable ByteBuffer container, int mark, int pos, int lim, int cap) {
+            super(address, container, mark, pos, lim, cap);
+        }
+
+        @Override
+        protected Buffer self() {
+            return this;
+        }
+
+        @Override
+        protected XrInstanceCreateInfoAndroidKHR getElementFactory() {
+            return ELEMENT_FACTORY;
+        }
+
+        /** @return the value of the {@code type} field. */
+        @NativeType("XrStructureType")
+        public int type() { return XrInstanceCreateInfoAndroidKHR.ntype(address()); }
+        /** @return the value of the {@code next} field. */
+        @NativeType("void const *")
+        public long next() { return XrInstanceCreateInfoAndroidKHR.nnext(address()); }
+        /** @return the value of the {@code applicationVM} field. */
+        @NativeType("void *")
+        public long applicationVM() { return XrInstanceCreateInfoAndroidKHR.napplicationVM(address()); }
+        /** @return the value of the {@code applicationActivity} field. */
+        @NativeType("void *")
+        public long applicationActivity() { return XrInstanceCreateInfoAndroidKHR.napplicationActivity(address()); }
+
+        /** Sets the specified value to the {@code type} field. */
+        public Buffer type(@NativeType("XrStructureType") int value) { XrInstanceCreateInfoAndroidKHR.ntype(address(), value); return this; }
+        /** Sets the {@link KHRAndroidCreateInstance#XR_TYPE_INSTANCE_CREATE_INFO_ANDROID_KHR TYPE_INSTANCE_CREATE_INFO_ANDROID_KHR} value to the {@code type} field. */
+        public Buffer type$Default() { return type(KHRAndroidCreateInstance.XR_TYPE_INSTANCE_CREATE_INFO_ANDROID_KHR); }
+        /** Sets the specified value to the {@code next} field. */
+        public Buffer next(@NativeType("void const *") long value) { XrInstanceCreateInfoAndroidKHR.nnext(address(), value); return this; }
+        /** Sets the specified value to the {@code applicationVM} field. */
+        public Buffer applicationVM(@NativeType("void *") long value) { XrInstanceCreateInfoAndroidKHR.napplicationVM(address(), value); return this; }
+        /** Sets the specified value to the {@code applicationActivity} field. */
+        public Buffer applicationActivity(@NativeType("void *") long value) { XrInstanceCreateInfoAndroidKHR.napplicationActivity(address(), value); return this; }
+
+    }
+
+}
Index: common/src/main/java/org/vivecraft/client/extensions/RenderTargetExtension.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/src/main/java/org/vivecraft/client/extensions/RenderTargetExtension.java b/common/src/main/java/org/vivecraft/client/extensions/RenderTargetExtension.java
--- a/common/src/main/java/org/vivecraft/client/extensions/RenderTargetExtension.java	(revision eaec65274edbf6dec8d28b76e7403b21c6b3145b)
+++ b/common/src/main/java/org/vivecraft/client/extensions/RenderTargetExtension.java	(revision a1131575d6931b12d3cb0b9f8a519b861bc5ca4c)
@@ -17,6 +17,8 @@
 
     void vivecraft$setTextid(int texid);
 
+    void vivecraft$setColorid(int colorid);
+
     void vivecraft$setUseStencil(boolean useStencil);
 
     boolean vivecraft$getUseStencil();
Index: common/src/main/java/org/vivecraft/client/gui/settings/GuiMainVRSettings.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/src/main/java/org/vivecraft/client/gui/settings/GuiMainVRSettings.java b/common/src/main/java/org/vivecraft/client/gui/settings/GuiMainVRSettings.java
--- a/common/src/main/java/org/vivecraft/client/gui/settings/GuiMainVRSettings.java	(revision eaec65274edbf6dec8d28b76e7403b21c6b3145b)
+++ b/common/src/main/java/org/vivecraft/client/gui/settings/GuiMainVRSettings.java	(revision a1131575d6931b12d3cb0b9f8a519b861bc5ca4c)
@@ -48,7 +48,7 @@
             return false;
         }, VROptionLayout.Position.POS_RIGHT, 2.0F, true, "gui.cancel"),
         new VROptionLayout((button, mousePos) -> {
-            this.dataholder.vrSettings.seated = true;
+            // this.dataholder.vrSettings.seated = true;
             this.settings.saveOptions();
             this.reinit = true;
             this.isConfirm = false;
Index: common/src/main/java/org/vivecraft/client/gui/settings/GuiRenderOpticsSettings.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/src/main/java/org/vivecraft/client/gui/settings/GuiRenderOpticsSettings.java b/common/src/main/java/org/vivecraft/client/gui/settings/GuiRenderOpticsSettings.java
--- a/common/src/main/java/org/vivecraft/client/gui/settings/GuiRenderOpticsSettings.java	(revision eaec65274edbf6dec8d28b76e7403b21c6b3145b)
+++ b/common/src/main/java/org/vivecraft/client/gui/settings/GuiRenderOpticsSettings.java	(revision a1131575d6931b12d3cb0b9f8a519b861bc5ca4c)
@@ -24,7 +24,7 @@
         VRSettings.VrOptions.HANDHELD_CAMERA_RENDER_SCALE,
         VRSettings.VrOptions.HANDHELD_CAMERA_FOV,
         VRSettings.VrOptions.RELOAD_EXTERNAL_CAMERA,
-        VRSettings.VrOptions.MIRROR_EYE
+        VRSettings.VrOptions.MIRROR_EYE,
     };
     static VRSettings.VrOptions[] MROptions = new VRSettings.VrOptions[]{
         VRSettings.VrOptions.MIXED_REALITY_UNITY_LIKE,
Index: common/src/main/java/org/vivecraft/client_vr/VRState.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/src/main/java/org/vivecraft/client_vr/VRState.java b/common/src/main/java/org/vivecraft/client_vr/VRState.java
--- a/common/src/main/java/org/vivecraft/client_vr/VRState.java	(revision eaec65274edbf6dec8d28b76e7403b21c6b3145b)
+++ b/common/src/main/java/org/vivecraft/client_vr/VRState.java	(revision a1131575d6931b12d3cb0b9f8a519b861bc5ca4c)
@@ -11,6 +11,7 @@
 import org.vivecraft.client_vr.menuworlds.MenuWorldRenderer;
 import org.vivecraft.client_vr.provider.nullvr.NullVR;
 import org.vivecraft.client_vr.provider.openvr_lwjgl.MCOpenVR;
+import org.vivecraft.client_vr.provider.openxr.MCOpenXR;
 import org.vivecraft.client_vr.render.RenderConfigException;
 import org.vivecraft.client_vr.settings.VRSettings;
 import org.vivecraft.client_xr.render_pass.RenderPassManager;
@@ -36,11 +37,13 @@
 
             vrInitialized = true;
             ClientDataHolderVR dh = ClientDataHolderVR.getInstance();
-            if (dh.vrSettings.stereoProviderPluginID == VRSettings.VRProvider.OPENVR) {
-                dh.vr = new MCOpenVR(Minecraft.getInstance(), dh);
-            } else {
-                dh.vr = new NullVR(Minecraft.getInstance(), dh);
+            Minecraft instance = Minecraft.getInstance();
+            switch (dh.vrSettings.stereoProviderPluginID) {
+                case OPENVR -> dh.vr = new MCOpenVR(instance, dh);
+                case OPENXR -> dh.vr = new MCOpenXR(instance, dh);
+                default -> dh.vr = new NullVR(instance, dh);
             }
+
             if (!dh.vr.init()) {
                 throw new RenderConfigException("VR Init Error", Component.translatable("vivecraft.messages.rendersetupfailed", dh.vr.initStatus, dh.vr.getName()));
             }
@@ -48,7 +51,7 @@
             dh.vrRenderer = dh.vr.createVRRenderer();
             dh.vrRenderer.lastGuiScale = Minecraft.getInstance().options.guiScale().get();
 
-            dh.vrRenderer.setupRenderConfiguration();
+            dh.vrRenderer.setupRenderConfiguration(false); //TODO look into why I have the boolean
             RenderPassManager.setVanillaRenderPass();
 
             dh.vrPlayer = new VRPlayer();
Index: common/src/main/java/org/vivecraft/client_vr/VRTextureTarget.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/src/main/java/org/vivecraft/client_vr/VRTextureTarget.java b/common/src/main/java/org/vivecraft/client_vr/VRTextureTarget.java
--- a/common/src/main/java/org/vivecraft/client_vr/VRTextureTarget.java	(revision eaec65274edbf6dec8d28b76e7403b21c6b3145b)
+++ b/common/src/main/java/org/vivecraft/client_vr/VRTextureTarget.java	(revision a1131575d6931b12d3cb0b9f8a519b861bc5ca4c)
@@ -1,14 +1,16 @@
 package org.vivecraft.client_vr;
 
 import com.mojang.blaze3d.pipeline.RenderTarget;
+import com.mojang.blaze3d.platform.GlStateManager;
 import com.mojang.blaze3d.systems.RenderSystem;
+import net.minecraft.client.Minecraft;
+import org.lwjgl.opengl.GL30;
 import org.vivecraft.client.Xplat;
 import org.vivecraft.client.extensions.RenderTargetExtension;
 
 public class VRTextureTarget extends RenderTarget {
 
     private final String name;
-
     public VRTextureTarget(String name, int width, int height, boolean usedepth, boolean onMac, int texid, boolean depthtex, boolean linearFilter, boolean useStencil) {
         super(usedepth);
         this.name = name;
@@ -22,6 +24,17 @@
         }
         this.setClearColor(0, 0, 0, 0);
     }
+
+    public VRTextureTarget(String name, int width, int height, int colorid, int index) {
+        super(true);
+        this.name = name;
+        RenderSystem.assertOnGameThreadOrInit();
+        this.resize(width, height, Minecraft.ON_OSX);
+        ((RenderTargetExtension) this).vivecraft$setColorid(colorid);
+        GlStateManager._glBindFramebuffer(GL30.GL_FRAMEBUFFER, frameBufferId);
+        GL30.glFramebufferTextureLayer(GL30.GL_FRAMEBUFFER, GL30.GL_COLOR_ATTACHMENT0, colorid, 0, index);
+        this.setClearColor(0, 0, 0, 0);
+    }
 
     @Override
     public String toString() {
Index: common/src/main/java/org/vivecraft/client_vr/gui/GuiRadial.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/src/main/java/org/vivecraft/client_vr/gui/GuiRadial.java b/common/src/main/java/org/vivecraft/client_vr/gui/GuiRadial.java
--- a/common/src/main/java/org/vivecraft/client_vr/gui/GuiRadial.java	(revision eaec65274edbf6dec8d28b76e7403b21c6b3145b)
+++ b/common/src/main/java/org/vivecraft/client_vr/gui/GuiRadial.java	(revision a1131575d6931b12d3cb0b9f8a519b861bc5ca4c)
@@ -7,7 +7,7 @@
 import net.minecraft.network.chat.Component;
 import org.vivecraft.client.gui.framework.TwoHandedScreen;
 import org.vivecraft.client_vr.provider.MCVR;
-import org.vivecraft.client_vr.provider.openvr_lwjgl.VRInputAction;
+import org.vivecraft.client_vr.provider.control.VRInputAction;
 
 public class GuiRadial extends TwoHandedScreen {
     private boolean isShift = false;
Index: common/src/main/java/org/vivecraft/client_vr/provider/ActionParams.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/src/main/java/org/vivecraft/client_vr/provider/ActionParams.java b/common/src/main/java/org/vivecraft/client_vr/provider/ActionParams.java
--- a/common/src/main/java/org/vivecraft/client_vr/provider/ActionParams.java	(revision eaec65274edbf6dec8d28b76e7403b21c6b3145b)
+++ b/common/src/main/java/org/vivecraft/client_vr/provider/ActionParams.java	(revision a1131575d6931b12d3cb0b9f8a519b861bc5ca4c)
@@ -1,6 +1,6 @@
 package org.vivecraft.client_vr.provider;
 
-import org.vivecraft.client_vr.provider.openvr_lwjgl.control.VRInputActionSet;
+import org.vivecraft.client_vr.provider.control.VRInputActionSet;
 
 public class ActionParams {
     public final VRInputActionSet actionSetOverride;
Index: common/src/main/java/org/vivecraft/client_vr/provider/MCVR.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/src/main/java/org/vivecraft/client_vr/provider/MCVR.java b/common/src/main/java/org/vivecraft/client_vr/provider/MCVR.java
--- a/common/src/main/java/org/vivecraft/client_vr/provider/MCVR.java	(revision eaec65274edbf6dec8d28b76e7403b21c6b3145b)
+++ b/common/src/main/java/org/vivecraft/client_vr/provider/MCVR.java	(revision a1131575d6931b12d3cb0b9f8a519b861bc5ca4c)
@@ -1,5 +1,6 @@
 package org.vivecraft.client_vr.provider;
 
+import com.mojang.blaze3d.platform.InputConstants;
 import net.minecraft.client.KeyMapping;
 import net.minecraft.client.Minecraft;
 import net.minecraft.client.gui.screens.ChatScreen;
@@ -25,9 +26,10 @@
 import org.vivecraft.client_vr.gameplay.screenhandlers.GuiHandler;
 import org.vivecraft.client_vr.gameplay.screenhandlers.KeyboardHandler;
 import org.vivecraft.client_vr.gameplay.screenhandlers.RadialHandler;
-import org.vivecraft.client_vr.provider.openvr_lwjgl.VRInputAction;
-import org.vivecraft.client_vr.provider.openvr_lwjgl.control.VRInputActionSet;
-import org.vivecraft.client_vr.provider.openvr_lwjgl.control.VivecraftMovementInput;
+import org.vivecraft.client_vr.provider.control.TrackpadSwipeSampler;
+import org.vivecraft.client_vr.provider.control.VRInputAction;
+import org.vivecraft.client_vr.provider.control.VRInputActionSet;
+import org.vivecraft.client_vr.provider.control.VivecraftMovementInput;
 import org.vivecraft.client_vr.render.RenderConfigException;
 import org.vivecraft.client_vr.render.RenderPass;
 import org.vivecraft.client_vr.settings.VRHotkeys;
@@ -108,6 +110,8 @@
     protected int quickTorchPreviousSlot;
     protected Map<String, VRInputAction> inputActions = new HashMap<>();
     protected Map<String, VRInputAction> inputActionsByKeyBinding = new HashMap<>();
+    protected final Map<String, TrackpadSwipeSampler> trackpadSwipeSamplers = new HashMap<>();
+    protected boolean inputInitialized;
 
     public MCVR(Minecraft mc, ClientDataHolderVR dh, VivecraftVRMod vrMod) {
         this.mc = mc;
@@ -131,7 +135,50 @@
 
     public abstract String getID();
 
-    public abstract void processInputs();
+    public void processInputs() {
+        if (!this.dh.vrSettings.seated && !ClientDataHolderVR.viewonly && this.inputInitialized) {
+            for (VRInputAction vrinputaction : this.inputActions.values()) {
+                if (vrinputaction.isHanded()) {
+                    for (ControllerType controllertype : ControllerType.values()) {
+                        vrinputaction.setCurrentHand(controllertype);
+                        this.processInputAction(vrinputaction);
+                    }
+                } else {
+                    this.processInputAction(vrinputaction);
+                }
+            }
+
+            this.processScrollInput(GuiHandler.keyScrollAxis, () ->
+            {
+                InputSimulator.scrollMouse(0.0D, 1.0D);
+            }, () ->
+            {
+                InputSimulator.scrollMouse(0.0D, -1.0D);
+            });
+            this.processScrollInput(VivecraftVRMod.INSTANCE.keyHotbarScroll, () ->
+            {
+                this.changeHotbar(-1);
+            }, () ->
+            {
+                this.changeHotbar(1);
+            });
+            this.processSwipeInput(VivecraftVRMod.INSTANCE.keyHotbarSwipeX, () ->
+            {
+                this.changeHotbar(1);
+            }, () ->
+            {
+                this.changeHotbar(-1);
+            }, null, null);
+            this.processSwipeInput(VivecraftVRMod.INSTANCE.keyHotbarSwipeY, null, null, () ->
+            {
+                this.changeHotbar(-1);
+            }, () ->
+            {
+                this.changeHotbar(1);
+            });
+            this.ignorePressesNextFrame = false;
+        }
+    }
 
     public abstract void destroy();
 
@@ -1145,6 +1192,76 @@
         }
     }
 
+    protected void processInputAction(VRInputAction action) {
+        if (action.isActive() && action.isEnabledRaw()
+            // try to prevent double left clicks
+            && (!ClientDataHolderVR.getInstance().vrSettings.ingameBindingsInGui
+            || !(action.actionSet == VRInputActionSet.INGAME && action.keyBinding.key.getType() == InputConstants.Type.MOUSE && action.keyBinding.key.getValue() == 0 && mc.screen != null))) {
+            if (action.isButtonChanged()) {
+                if (action.isButtonPressed() && action.isEnabled()) {
+                    if (!this.ignorePressesNextFrame) {
+                        action.pressBinding();
+                    }
+                } else {
+                    action.unpressBinding();
+                }
+            }
+        } else {
+            action.unpressBinding();
+        }
+    }
+
+    protected void processScrollInput(KeyMapping keyBinding, Runnable upCallback, Runnable downCallback) {
+        VRInputAction vrinputaction = this.getInputAction(keyBinding);
+
+        if (vrinputaction.isEnabled() && vrinputaction.getLastOrigin() != 0L && vrinputaction.getAxis2D(true).getY() != 0.0F) {
+            float f = vrinputaction.getAxis2D(false).getY();
+
+            if (f > 0.0F) {
+                upCallback.run();
+            } else if (f < 0.0F) {
+                downCallback.run();
+            }
+        }
+    }
+
+    protected void processSwipeInput(KeyMapping keyBinding, Runnable leftCallback, Runnable rightCallback, Runnable upCallback, Runnable downCallback) {
+        VRInputAction vrinputaction = this.getInputAction(keyBinding);
+
+        if (vrinputaction.isEnabled() && vrinputaction.getLastOrigin() != 0L) {
+            ControllerType controllertype = this.findActiveBindingControllerType(keyBinding);
+
+            if (controllertype != null) {
+                if (!this.trackpadSwipeSamplers.containsKey(keyBinding.getName())) {
+                    this.trackpadSwipeSamplers.put(keyBinding.getName(), new TrackpadSwipeSampler());
+                }
+
+                TrackpadSwipeSampler trackpadswipesampler = this.trackpadSwipeSamplers.get(keyBinding.getName());
+                trackpadswipesampler.update(controllertype, vrinputaction.getAxis2D(false));
+
+                if (trackpadswipesampler.isSwipedUp() && upCallback != null) {
+                    this.triggerHapticPulse(controllertype, 0.001F, 400.0F, 0.5F);
+                    upCallback.run();
+                }
+
+                if (trackpadswipesampler.isSwipedDown() && downCallback != null) {
+                    this.triggerHapticPulse(controllertype, 0.001F, 400.0F, 0.5F);
+                    downCallback.run();
+                }
+
+                if (trackpadswipesampler.isSwipedLeft() && leftCallback != null) {
+                    this.triggerHapticPulse(controllertype, 0.001F, 400.0F, 0.5F);
+                    leftCallback.run();
+                }
+
+                if (trackpadswipesampler.isSwipedRight() && rightCallback != null) {
+                    this.triggerHapticPulse(controllertype, 0.001F, 400.0F, 0.5F);
+                    rightCallback.run();
+                }
+            }
+        }
+    }
+
     private void addActionParams(Map<String, ActionParams> map, KeyMapping keyBinding, String requirement, String type, VRInputActionSet actionSetOverride) {
         ActionParams actionparams = new ActionParams(requirement, type, actionSetOverride);
         map.put(keyBinding.getName(), actionparams);
@@ -1174,6 +1291,7 @@
 
     public abstract boolean isActive();
 
+    public abstract ControllerType getOriginControllerType(long i);
     public boolean capFPS() {
         return false;
     }
Index: common/src/main/java/org/vivecraft/client_vr/provider/VRRenderer.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/src/main/java/org/vivecraft/client_vr/provider/VRRenderer.java b/common/src/main/java/org/vivecraft/client_vr/provider/VRRenderer.java
--- a/common/src/main/java/org/vivecraft/client_vr/provider/VRRenderer.java	(revision eaec65274edbf6dec8d28b76e7403b21c6b3145b)
+++ b/common/src/main/java/org/vivecraft/client_vr/provider/VRRenderer.java	(revision a1131575d6931b12d3cb0b9f8a519b861bc5ca4c)
@@ -55,8 +55,6 @@
     protected int dispLastWidth;
     protected int dispLastHeight;
     public Matrix4f[] eyeproj = new Matrix4f[2];
-    public RenderTarget framebufferEye0;
-    public RenderTarget framebufferEye1;
     public RenderTarget framebufferMR;
     public RenderTarget framebufferUndistorted;
     public RenderTarget framebufferVrRender;
@@ -75,8 +73,6 @@
     public int lastRenderDistanceChunks = -1;
     public long lastWindow = 0L;
     public float lastWorldScale = 0.0F;
-    protected int LeftEyeTextureId = -1;
-    protected int RightEyeTextureId = -1;
     public int mirrorFBHeight;
     public int mirrorFBWidth;
     protected boolean reinitFramebuffers = true;
@@ -101,7 +97,7 @@
         }
     }
 
-    public abstract void createRenderTexture(int var1, int var2);
+    public abstract void createRenderTexture(int var1, int var2) throws RenderConfigException;
 
     public abstract Matrix4f getProjectionMatrix(int var1, float var2, float var3);
 
@@ -109,17 +105,8 @@
 
     public abstract boolean providesStencilMask();
 
-    public void deleteRenderTextures() {
-        if (this.LeftEyeTextureId > 0) {
-            RenderSystem.deleteTexture(this.LeftEyeTextureId);
-        }
-
-        if (this.RightEyeTextureId > 0) {
-            RenderSystem.deleteTexture(this.RightEyeTextureId);
-        }
-
-        this.LeftEyeTextureId = this.RightEyeTextureId = -1;
-    }
+    public abstract RenderTarget getLeftEyeTarget();
+    public abstract RenderTarget getRightEyeTarget();
 
     public void doStencil(boolean inverse) {
         Minecraft minecraft = Minecraft.getInstance();
@@ -437,7 +424,7 @@
         this.resizeFrameBuffers = true;
     }
 
-    public void setupRenderConfiguration() throws Exception {
+    public void setupRenderConfiguration(boolean render) throws Exception {
         Minecraft minecraft = Minecraft.getInstance();
         ClientDataHolderVR dataholder = ClientDataHolderVR.getInstance();
 
@@ -529,6 +516,10 @@
             }
         }
 
+        //for OPENXR, it needs to reinit
+        this.eyeproj[0] = this.getProjectionMatrix(0, ((GameRendererExtension) minecraft.gameRenderer).vivecraft$getMinClipDistance(), ((GameRendererExtension) minecraft.gameRenderer).vivecraft$getClipDistance());
+        this.eyeproj[1] = this.getProjectionMatrix(1, ((GameRendererExtension) minecraft.gameRenderer).vivecraft$getMinClipDistance(), ((GameRendererExtension) minecraft.gameRenderer).vivecraft$getClipDistance());
+
         if (this.reinitFramebuffers) {
             this.reinitShadersFlag = true;
             this.checkGLError("Start Init");
@@ -568,31 +559,8 @@
 
             destroy();
 
-            if (this.LeftEyeTextureId == -1) {
-                this.createRenderTexture(eyew, eyeh);
+            this.createRenderTexture(eyew, eyeh);
 
-                if (this.LeftEyeTextureId == -1) {
-                    throw new RenderConfigException("Failed to initialise stereo rendering plugin: " + this.getName(), Component.literal(this.getLastError()));
-                }
-
-                dataholder.print("Provider supplied render texture IDs: " + this.LeftEyeTextureId + " " + this.RightEyeTextureId);
-                dataholder.print("Provider supplied texture resolution: " + eyew + " x " + eyeh);
-            }
-
-            this.checkGLError("Render Texture setup");
-
-            if (this.framebufferEye0 == null) {
-                this.framebufferEye0 = new VRTextureTarget("L Eye", eyew, eyeh, false, false, this.LeftEyeTextureId, false, true, false);
-                dataholder.print(this.framebufferEye0.toString());
-                this.checkGLError("Left Eye framebuffer setup");
-            }
-
-            if (this.framebufferEye1 == null) {
-                this.framebufferEye1 = new VRTextureTarget("R Eye", eyew, eyeh, false, false, this.RightEyeTextureId, false, true, false);
-                dataholder.print(this.framebufferEye1.toString());
-                this.checkGLError("Right Eye framebuffer setup");
-            }
-
             float resolutionScale = ResolutionControlHelper.isLoaded() ? ResolutionControlHelper.getCurrentScaleFactor() : 1.0F;
 
             this.renderScale = (float) Math.sqrt(dataholder.vrSettings.renderScaleFactor) * resolutionScale;
@@ -706,6 +674,8 @@
                 ShaderHelper.checkGLError("init FOV shader");
                 VRShaders.setupPortalShaders();
                 ShaderHelper.checkGLError("init portal shader");
+                VRShaders.setupGSR();
+                ShaderHelper.checkGLError("init gsr shader");
                 minecraft.gameRenderer.checkEntityPostEffect(minecraft.getCameraEntity());
             } catch (Exception exception1) {
                 System.out.println(exception1.getMessage());
@@ -826,15 +796,5 @@
             this.fsaaLastPassResultFBO.destroyBuffers();
             this.fsaaLastPassResultFBO = null;
         }
-
-        if (this.framebufferEye0 != null) {
-            this.framebufferEye0.destroyBuffers();
-            this.framebufferEye0 = null;
-        }
-
-        if (this.framebufferEye1 != null) {
-            this.framebufferEye1.destroyBuffers();
-            this.framebufferEye1 = null;
-        }
     }
 }
Index: common/src/main/java/org/vivecraft/client_vr/provider/openvr_lwjgl/control/HapticMusicPlayer.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/src/main/java/org/vivecraft/client_vr/provider/openvr_lwjgl/control/HapticMusicPlayer.java b/common/src/main/java/org/vivecraft/client_vr/provider/control/HapticMusicPlayer.java
rename from common/src/main/java/org/vivecraft/client_vr/provider/openvr_lwjgl/control/HapticMusicPlayer.java
rename to common/src/main/java/org/vivecraft/client_vr/provider/control/HapticMusicPlayer.java
--- a/common/src/main/java/org/vivecraft/client_vr/provider/openvr_lwjgl/control/HapticMusicPlayer.java	(revision eaec65274edbf6dec8d28b76e7403b21c6b3145b)
+++ b/common/src/main/java/org/vivecraft/client_vr/provider/control/HapticMusicPlayer.java	(revision a1131575d6931b12d3cb0b9f8a519b861bc5ca4c)
@@ -1,7 +1,7 @@
-package org.vivecraft.client_vr.provider.openvr_lwjgl.control;
+package org.vivecraft.client_vr.provider.control;
 
+import org.vivecraft.client_vr.ClientDataHolderVR;
 import org.vivecraft.client_vr.provider.ControllerType;
-import org.vivecraft.client_vr.provider.openvr_lwjgl.MCOpenVR;
 
 import javax.annotation.Nullable;
 import java.util.HashMap;
@@ -62,10 +62,10 @@
                 if (object instanceof Note hapticmusicplayer$music$note) {
 
                     if (hapticmusicplayer$music$note.controller != null) {
-                        MCOpenVR.get().triggerHapticPulse(hapticmusicplayer$music$note.controller, hapticmusicplayer$music$note.durationSeconds, hapticmusicplayer$music$note.frequency, hapticmusicplayer$music$note.amplitude, f);
+                        ClientDataHolderVR.getInstance().vr.triggerHapticPulse(hapticmusicplayer$music$note.controller, hapticmusicplayer$music$note.durationSeconds, hapticmusicplayer$music$note.frequency, hapticmusicplayer$music$note.amplitude, f);
                     } else {
-                        MCOpenVR.get().triggerHapticPulse(ControllerType.RIGHT, hapticmusicplayer$music$note.durationSeconds, hapticmusicplayer$music$note.frequency, hapticmusicplayer$music$note.amplitude, f);
-                        MCOpenVR.get().triggerHapticPulse(ControllerType.LEFT, hapticmusicplayer$music$note.durationSeconds, hapticmusicplayer$music$note.frequency, hapticmusicplayer$music$note.amplitude, f);
+                        ClientDataHolderVR.getInstance().vr.get().triggerHapticPulse(ControllerType.RIGHT, hapticmusicplayer$music$note.durationSeconds, hapticmusicplayer$music$note.frequency, hapticmusicplayer$music$note.amplitude, f);
+                        ClientDataHolderVR.getInstance().vr.get().triggerHapticPulse(ControllerType.LEFT, hapticmusicplayer$music$note.durationSeconds, hapticmusicplayer$music$note.frequency, hapticmusicplayer$music$note.amplitude, f);
                     }
                 } else if (object instanceof Delay hapticmusicplayer$music$delay) {
                     f += hapticmusicplayer$music$delay.durationSeconds;
Index: common/src/main/java/org/vivecraft/client_vr/provider/openvr_lwjgl/control/TrackpadSwipeSampler.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/src/main/java/org/vivecraft/client_vr/provider/openvr_lwjgl/control/TrackpadSwipeSampler.java b/common/src/main/java/org/vivecraft/client_vr/provider/control/TrackpadSwipeSampler.java
rename from common/src/main/java/org/vivecraft/client_vr/provider/openvr_lwjgl/control/TrackpadSwipeSampler.java
rename to common/src/main/java/org/vivecraft/client_vr/provider/control/TrackpadSwipeSampler.java
--- a/common/src/main/java/org/vivecraft/client_vr/provider/openvr_lwjgl/control/TrackpadSwipeSampler.java	(revision eaec65274edbf6dec8d28b76e7403b21c6b3145b)
+++ b/common/src/main/java/org/vivecraft/client_vr/provider/control/TrackpadSwipeSampler.java	(revision a1131575d6931b12d3cb0b9f8a519b861bc5ca4c)
@@ -1,8 +1,8 @@
-package org.vivecraft.client_vr.provider.openvr_lwjgl.control;
+package org.vivecraft.client_vr.provider.control;
 
 import org.vivecraft.client.VivecraftVRMod;
+import org.vivecraft.client_vr.ClientDataHolderVR;
 import org.vivecraft.client_vr.provider.ControllerType;
-import org.vivecraft.client_vr.provider.openvr_lwjgl.MCOpenVR;
 import org.vivecraft.common.utils.lwjgl.Vector2f;
 import org.vivecraft.common.utils.math.Vector2;
 
@@ -25,9 +25,9 @@
     }
 
     public void update(ControllerType hand, Vector2 position) {
-        MCOpenVR.get().getInputAction(VivecraftVRMod.INSTANCE.keyTrackpadTouch).setCurrentHand(hand);
+        ClientDataHolderVR.getInstance().vr.getInputAction(VivecraftVRMod.INSTANCE.keyTrackpadTouch).setCurrentHand(hand);
 
-        if (MCOpenVR.get().getInputAction(VivecraftVRMod.INSTANCE.keyTrackpadTouch).isButtonPressed()) {
+        if (ClientDataHolderVR.getInstance().vr.getInputAction(VivecraftVRMod.INSTANCE.keyTrackpadTouch).isButtonPressed()) {
             this.buffer[this.index].set(position.getX(), position.getY());
 
             if (++this.index >= this.buffer.length) {
Index: common/src/main/java/org/vivecraft/client_vr/provider/openvr_lwjgl/VRInputAction.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/src/main/java/org/vivecraft/client_vr/provider/openvr_lwjgl/VRInputAction.java b/common/src/main/java/org/vivecraft/client_vr/provider/control/VRInputAction.java
rename from common/src/main/java/org/vivecraft/client_vr/provider/openvr_lwjgl/VRInputAction.java
rename to common/src/main/java/org/vivecraft/client_vr/provider/control/VRInputAction.java
--- a/common/src/main/java/org/vivecraft/client_vr/provider/openvr_lwjgl/VRInputAction.java	(revision eaec65274edbf6dec8d28b76e7403b21c6b3145b)
+++ b/common/src/main/java/org/vivecraft/client_vr/provider/control/VRInputAction.java	(revision a1131575d6931b12d3cb0b9f8a519b861bc5ca4c)
@@ -1,13 +1,12 @@
-package org.vivecraft.client_vr.provider.openvr_lwjgl;
+package org.vivecraft.client_vr.provider.control;
 
 import com.mojang.blaze3d.platform.InputConstants;
 import net.minecraft.client.KeyMapping;
 import org.vivecraft.client.VivecraftVRMod;
+import org.vivecraft.client_vr.ClientDataHolderVR;
 import org.vivecraft.client_vr.provider.ControllerType;
 import org.vivecraft.client_vr.provider.HandedKeyBinding;
 import org.vivecraft.client_vr.provider.InputSimulator;
-import org.vivecraft.client_vr.provider.MCVR;
-import org.vivecraft.client_vr.provider.openvr_lwjgl.control.VRInputActionSet;
 import org.vivecraft.common.utils.math.Vector2;
 import org.vivecraft.common.utils.math.Vector3;
 
@@ -219,17 +218,17 @@
     public boolean isEnabled() {
         if (!this.isEnabledRaw(this.currentHand)) {
             return false;
-        } else if (MCOpenVR.get() == null) {
+        } else if (ClientDataHolderVR.getInstance().vr == null) {
             return false;
         } else {
             long i = this.getLastOrigin();
-            ControllerType controllertype = MCOpenVR.get().getOriginControllerType(i);
+            ControllerType controllertype = ClientDataHolderVR.getInstance().vr.getOriginControllerType(i);
 
             if (controllertype == null && this.isHanded()) {
                 return false;
             } else {
-                for (VRInputAction vrinputaction : MCOpenVR.get().getInputActions()) {
-                    if (vrinputaction != this && vrinputaction.isEnabledRaw(controllertype) && vrinputaction.isActive() && vrinputaction.getPriority() > this.getPriority() && MCVR.get().getOrigins(vrinputaction).contains(i)) {
+                for (VRInputAction vrinputaction : ClientDataHolderVR.getInstance().vr.getInputActions()) {
+                    if (vrinputaction != this && vrinputaction.isEnabledRaw(controllertype) && vrinputaction.isActive() && vrinputaction.getPriority() > this.getPriority() && ClientDataHolderVR.getInstance().vr.getOrigins(vrinputaction).contains(i)) {
                         if (vrinputaction.isHanded()) {
                             return !((HandedKeyBinding) vrinputaction.keyBinding).isPriorityOnController(controllertype);
                         }
Index: common/src/main/java/org/vivecraft/client_vr/provider/openvr_lwjgl/control/VRInputActionSet.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/src/main/java/org/vivecraft/client_vr/provider/openvr_lwjgl/control/VRInputActionSet.java b/common/src/main/java/org/vivecraft/client_vr/provider/control/VRInputActionSet.java
rename from common/src/main/java/org/vivecraft/client_vr/provider/openvr_lwjgl/control/VRInputActionSet.java
rename to common/src/main/java/org/vivecraft/client_vr/provider/control/VRInputActionSet.java
--- a/common/src/main/java/org/vivecraft/client_vr/provider/openvr_lwjgl/control/VRInputActionSet.java	(revision eaec65274edbf6dec8d28b76e7403b21c6b3145b)
+++ b/common/src/main/java/org/vivecraft/client_vr/provider/control/VRInputActionSet.java	(revision a1131575d6931b12d3cb0b9f8a519b861bc5ca4c)
@@ -1,4 +1,4 @@
-package org.vivecraft.client_vr.provider.openvr_lwjgl.control;
+package org.vivecraft.client_vr.provider.control;
 
 import net.minecraft.client.KeyMapping;
 import org.vivecraft.client.VivecraftVRMod;
Index: common/src/main/java/org/vivecraft/client_vr/provider/control/VivecraftMovementInput.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/src/main/java/org/vivecraft/client_vr/provider/control/VivecraftMovementInput.java b/common/src/main/java/org/vivecraft/client_vr/provider/control/VivecraftMovementInput.java
new file mode 100644
--- /dev/null	(revision a1131575d6931b12d3cb0b9f8a519b861bc5ca4c)
+++ b/common/src/main/java/org/vivecraft/client_vr/provider/control/VivecraftMovementInput.java	(revision a1131575d6931b12d3cb0b9f8a519b861bc5ca4c)
@@ -0,0 +1,11 @@
+package org.vivecraft.client_vr.provider.control;
+
+import net.minecraft.client.KeyMapping;
+import org.vivecraft.client_vr.ClientDataHolderVR;
+
+public class VivecraftMovementInput {
+    public static float getMovementAxisValue(KeyMapping keyBinding) {
+        VRInputAction vrinputaction = ClientDataHolderVR.getInstance().vr.getInputAction(keyBinding);
+        return Math.abs(vrinputaction.getAxis1DUseTracked());
+    }
+}
Index: common/src/main/java/org/vivecraft/client_vr/provider/nullvr/NullVR.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/src/main/java/org/vivecraft/client_vr/provider/nullvr/NullVR.java b/common/src/main/java/org/vivecraft/client_vr/provider/nullvr/NullVR.java
--- a/common/src/main/java/org/vivecraft/client_vr/provider/nullvr/NullVR.java	(revision eaec65274edbf6dec8d28b76e7403b21c6b3145b)
+++ b/common/src/main/java/org/vivecraft/client_vr/provider/nullvr/NullVR.java	(revision a1131575d6931b12d3cb0b9f8a519b861bc5ca4c)
@@ -12,7 +12,7 @@
 import org.vivecraft.client_vr.provider.ControllerType;
 import org.vivecraft.client_vr.provider.MCVR;
 import org.vivecraft.client_vr.provider.VRRenderer;
-import org.vivecraft.client_vr.provider.openvr_lwjgl.VRInputAction;
+import org.vivecraft.client_vr.provider.control.VRInputAction;
 import org.vivecraft.common.utils.math.Matrix4f;
 
 import java.util.List;
@@ -193,6 +193,11 @@
         return vrActive;
     }
 
+    @Override
+    public ControllerType getOriginControllerType(long i) {
+        return ControllerType.LEFT;
+    }
+
     @Override
     public boolean capFPS() {
         return true;
Index: common/src/main/java/org/vivecraft/client_vr/provider/nullvr/NullVRStereoRenderer.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/src/main/java/org/vivecraft/client_vr/provider/nullvr/NullVRStereoRenderer.java b/common/src/main/java/org/vivecraft/client_vr/provider/nullvr/NullVRStereoRenderer.java
--- a/common/src/main/java/org/vivecraft/client_vr/provider/nullvr/NullVRStereoRenderer.java	(revision eaec65274edbf6dec8d28b76e7403b21c6b3145b)
+++ b/common/src/main/java/org/vivecraft/client_vr/provider/nullvr/NullVRStereoRenderer.java	(revision a1131575d6931b12d3cb0b9f8a519b861bc5ca4c)
@@ -1,16 +1,27 @@
 package org.vivecraft.client_vr.provider.nullvr;
 
+import com.mojang.blaze3d.pipeline.RenderTarget;
 import com.mojang.blaze3d.platform.GlStateManager;
 import com.mojang.blaze3d.platform.TextureUtil;
 import com.mojang.blaze3d.systems.RenderSystem;
+import net.minecraft.network.chat.Component;
 import net.minecraft.util.Tuple;
 import org.joml.Matrix4f;
 import org.lwjgl.opengl.GL11;
+import org.vivecraft.client_vr.ClientDataHolderVR;
+import org.vivecraft.client_vr.VRTextureTarget;
 import org.vivecraft.client_vr.provider.MCVR;
 import org.vivecraft.client_vr.provider.VRRenderer;
+import org.vivecraft.client_vr.render.RenderConfigException;
 import org.vivecraft.client_vr.render.RenderPass;
 
 public class NullVRStereoRenderer extends VRRenderer {
+
+    protected int LeftEyeTextureId = -1;
+    protected int RightEyeTextureId = -1;
+    public RenderTarget framebufferEye0;
+    public RenderTarget framebufferEye1;
+
     public NullVRStereoRenderer(MCVR vr) {
         super(vr);
     }
@@ -40,7 +51,7 @@
     }
 
     @Override
-    public void createRenderTexture(int lwidth, int lheight) {
+    public void createRenderTexture(int lwidth, int lheight) throws RenderConfigException {
         this.LeftEyeTextureId = GlStateManager._genTexture();
         int i = GlStateManager._getInteger(GL11.GL_TEXTURE_BINDING_2D);
         RenderSystem.bindTexture(this.LeftEyeTextureId);
@@ -56,6 +67,25 @@
         RenderSystem.texParameter(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MAG_FILTER, GL11.GL_LINEAR);
         GlStateManager._texImage2D(GL11.GL_TEXTURE_2D, 0, GL11.GL_RGBA8, lwidth, lheight, 0, GL11.GL_RGBA, GL11.GL_INT, null);
         RenderSystem.bindTexture(i);
+
+        ClientDataHolderVR dataholder = ClientDataHolderVR.getInstance();
+        if (this.LeftEyeTextureId == -1) {
+            throw new RenderConfigException("Failed to initialise stereo rendering plugin: " + this.getName(), Component.literal(this.getLastError()));
+        }
+
+        this.checkGLError("Render Texture setup");
+
+        if (this.framebufferEye0 == null) {
+            this.framebufferEye0 = new VRTextureTarget("L Eye", lwidth, lheight, false, false, this.LeftEyeTextureId, false, true, false);
+            dataholder.print(this.framebufferEye0.toString());
+            this.checkGLError("Left Eye framebuffer setup");
+        }
+
+        if (this.framebufferEye1 == null) {
+            this.framebufferEye1 = new VRTextureTarget("R Eye", lwidth, lheight, false, false, this.RightEyeTextureId, false, true, false);
+            dataholder.print(this.framebufferEye1.toString());
+            this.checkGLError("Right Eye framebuffer setup");
+        }
     }
 
     @Override
@@ -67,6 +97,16 @@
         return false;
     }
 
+    @Override
+    public RenderTarget getLeftEyeTarget() {
+        return framebufferEye0;
+    }
+
+    @Override
+    public RenderTarget getRightEyeTarget() {
+        return framebufferEye1;
+    }
+
 
     @Override
     public float[] getStencilMask(RenderPass eye) {
@@ -91,6 +131,15 @@
     @Override
     public void destroy() {
         super.destroy();
+        if (this.framebufferEye0 != null) {
+            this.framebufferEye0.destroyBuffers();
+            this.framebufferEye0 = null;
+        }
+
+        if (this.framebufferEye1 != null) {
+            this.framebufferEye1.destroyBuffers();
+            this.framebufferEye1 = null;
+        }
         if (this.LeftEyeTextureId > -1) {
             TextureUtil.releaseTextureId(this.LeftEyeTextureId);
             this.LeftEyeTextureId = -1;
Index: common/src/main/java/org/vivecraft/client_vr/provider/openvr_lwjgl/MCOpenVR.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/src/main/java/org/vivecraft/client_vr/provider/openvr_lwjgl/MCOpenVR.java b/common/src/main/java/org/vivecraft/client_vr/provider/openvr_lwjgl/MCOpenVR.java
--- a/common/src/main/java/org/vivecraft/client_vr/provider/openvr_lwjgl/MCOpenVR.java	(revision eaec65274edbf6dec8d28b76e7403b21c6b3145b)
+++ b/common/src/main/java/org/vivecraft/client_vr/provider/openvr_lwjgl/MCOpenVR.java	(revision a1131575d6931b12d3cb0b9f8a519b861bc5ca4c)
@@ -24,8 +24,9 @@
 import org.vivecraft.client_vr.gameplay.screenhandlers.KeyboardHandler;
 import org.vivecraft.client_vr.gameplay.screenhandlers.RadialHandler;
 import org.vivecraft.client_vr.provider.*;
-import org.vivecraft.client_vr.provider.openvr_lwjgl.control.TrackpadSwipeSampler;
-import org.vivecraft.client_vr.provider.openvr_lwjgl.control.VRInputActionSet;
+import org.vivecraft.client_vr.provider.control.TrackpadSwipeSampler;
+import org.vivecraft.client_vr.provider.control.VRInputAction;
+import org.vivecraft.client_vr.provider.control.VRInputActionSet;
 import org.vivecraft.client_vr.render.RenderConfigException;
 import org.vivecraft.client_vr.settings.VRHotkeys;
 import org.vivecraft.client_vr.settings.VRSettings;
@@ -76,7 +77,6 @@
     private final IntBuffer hmdErrorStore = MemoryUtil.memCallocInt(1);
     private IntBuffer hmdErrorStoreBuf;
     private TrackedDevicePose.Buffer hmdTrackedDevicePoses;
-    private boolean inputInitialized;
     private long leftControllerHandle;
     private long leftHapticHandle;
     private long leftPoseHandle;
@@ -87,7 +87,6 @@
     private long rightHapticHandle;
     private long rightPoseHandle;
     private final VRTextureBounds texBounds = VRTextureBounds.calloc();
-    private final Map<String, TrackpadSwipeSampler> trackpadSwipeSamplers = new HashMap<>();
     private boolean tried;
     private final Queue<VREvent> vrEvents = new LinkedList<>();
     final Texture texType0 = Texture.calloc();
@@ -367,51 +366,6 @@
         }
     }
 
-    public void processInputs() {
-        if (!this.dh.vrSettings.seated && !ClientDataHolderVR.viewonly && this.inputInitialized) {
-            for (VRInputAction vrinputaction : this.inputActions.values()) {
-                if (vrinputaction.isHanded()) {
-                    for (ControllerType controllertype : ControllerType.values()) {
-                        vrinputaction.setCurrentHand(controllertype);
-                        this.processInputAction(vrinputaction);
-                    }
-                } else {
-                    this.processInputAction(vrinputaction);
-                }
-            }
-
-            this.processScrollInput(GuiHandler.keyScrollAxis, () ->
-            {
-                InputSimulator.scrollMouse(0.0D, 1.0D);
-            }, () ->
-            {
-                InputSimulator.scrollMouse(0.0D, -1.0D);
-            });
-            this.processScrollInput(VivecraftVRMod.INSTANCE.keyHotbarScroll, () ->
-            {
-                this.changeHotbar(-1);
-            }, () ->
-            {
-                this.changeHotbar(1);
-            });
-            this.processSwipeInput(VivecraftVRMod.INSTANCE.keyHotbarSwipeX, () ->
-            {
-                this.changeHotbar(1);
-            }, () ->
-            {
-                this.changeHotbar(-1);
-            }, null, null);
-            this.processSwipeInput(VivecraftVRMod.INSTANCE.keyHotbarSwipeY, null, null, () ->
-            {
-                this.changeHotbar(-1);
-            }, () ->
-            {
-                this.changeHotbar(1);
-            });
-            this.ignorePressesNextFrame = false;
-        }
-    }
-
     @Deprecated
     protected void triggerBindingHapticPulse(KeyMapping binding, int duration) {
         ControllerType controllertype = this.findActiveBindingControllerType(binding);
@@ -998,76 +952,6 @@
         }
     }
 
-    private void processInputAction(VRInputAction action) {
-        if (action.isActive() && action.isEnabledRaw()
-            // try to prevent double left clicks
-            && (!ClientDataHolderVR.getInstance().vrSettings.ingameBindingsInGui
-            || !(action.actionSet == VRInputActionSet.INGAME && action.keyBinding.key.getType() == InputConstants.Type.MOUSE && action.keyBinding.key.getValue() == 0 && mc.screen != null))) {
-            if (action.isButtonChanged()) {
-                if (action.isButtonPressed() && action.isEnabled()) {
-                    if (!this.ignorePressesNextFrame) {
-                        action.pressBinding();
-                    }
-                } else {
-                    action.unpressBinding();
-                }
-            }
-        } else {
-            action.unpressBinding();
-        }
-    }
-
-    private void processScrollInput(KeyMapping keyBinding, Runnable upCallback, Runnable downCallback) {
-        VRInputAction vrinputaction = this.getInputAction(keyBinding);
-
-        if (vrinputaction.isEnabled() && vrinputaction.getLastOrigin() != 0L && vrinputaction.getAxis2D(true).getY() != 0.0F) {
-            float f = vrinputaction.getAxis2D(false).getY();
-
-            if (f > 0.0F) {
-                upCallback.run();
-            } else if (f < 0.0F) {
-                downCallback.run();
-            }
-        }
-    }
-
-    private void processSwipeInput(KeyMapping keyBinding, Runnable leftCallback, Runnable rightCallback, Runnable upCallback, Runnable downCallback) {
-        VRInputAction vrinputaction = this.getInputAction(keyBinding);
-
-        if (vrinputaction.isEnabled() && vrinputaction.getLastOrigin() != 0L) {
-            ControllerType controllertype = this.findActiveBindingControllerType(keyBinding);
-
-            if (controllertype != null) {
-                if (!this.trackpadSwipeSamplers.containsKey(keyBinding.getName())) {
-                    this.trackpadSwipeSamplers.put(keyBinding.getName(), new TrackpadSwipeSampler());
-                }
-
-                TrackpadSwipeSampler trackpadswipesampler = this.trackpadSwipeSamplers.get(keyBinding.getName());
-                trackpadswipesampler.update(controllertype, vrinputaction.getAxis2D(false));
-
-                if (trackpadswipesampler.isSwipedUp() && upCallback != null) {
-                    this.triggerHapticPulse(controllertype, 0.001F, 400.0F, 0.5F);
-                    upCallback.run();
-                }
-
-                if (trackpadswipesampler.isSwipedDown() && downCallback != null) {
-                    this.triggerHapticPulse(controllertype, 0.001F, 400.0F, 0.5F);
-                    downCallback.run();
-                }
-
-                if (trackpadswipesampler.isSwipedLeft() && leftCallback != null) {
-                    this.triggerHapticPulse(controllertype, 0.001F, 400.0F, 0.5F);
-                    leftCallback.run();
-                }
-
-                if (trackpadswipesampler.isSwipedRight() && rightCallback != null) {
-                    this.triggerHapticPulse(controllertype, 0.001F, 400.0F, 0.5F);
-                    rightCallback.run();
-                }
-            }
-        }
-    }
-
     private void processVREvents() {
         while (!this.vrEvents.isEmpty()) {
             VREvent vrevent = this.vrEvents.poll();
@@ -1268,7 +1152,7 @@
         }
     }
 
-    ControllerType getOriginControllerType(long inputValueHandle) {
+    public ControllerType getOriginControllerType(long inputValueHandle) {
         if (inputValueHandle == 0L) {
             return null;
         } else {
Index: common/src/main/java/org/vivecraft/client_vr/provider/openvr_lwjgl/OpenVRStereoRenderer.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/src/main/java/org/vivecraft/client_vr/provider/openvr_lwjgl/OpenVRStereoRenderer.java b/common/src/main/java/org/vivecraft/client_vr/provider/openvr_lwjgl/OpenVRStereoRenderer.java
--- a/common/src/main/java/org/vivecraft/client_vr/provider/openvr_lwjgl/OpenVRStereoRenderer.java	(revision eaec65274edbf6dec8d28b76e7403b21c6b3145b)
+++ b/common/src/main/java/org/vivecraft/client_vr/provider/openvr_lwjgl/OpenVRStereoRenderer.java	(revision a1131575d6931b12d3cb0b9f8a519b861bc5ca4c)
@@ -1,5 +1,6 @@
 package org.vivecraft.client_vr.provider.openvr_lwjgl;
 
+import com.mojang.blaze3d.pipeline.RenderTarget;
 import com.mojang.blaze3d.platform.GlStateManager;
 import com.mojang.blaze3d.platform.TextureUtil;
 import com.mojang.blaze3d.systems.RenderSystem;
@@ -14,10 +15,12 @@
 import org.lwjgl.system.MemoryStack;
 import org.lwjgl.system.MemoryUtil;
 import org.vivecraft.client.utils.Utils;
-import org.vivecraft.client_vr.provider.MCVR;
+import org.vivecraft.client_vr.ClientDataHolderVR;
+import org.vivecraft.client_vr.VRTextureTarget;
 import org.vivecraft.client_vr.provider.VRRenderer;
 import org.vivecraft.client_vr.render.RenderConfigException;
 import org.vivecraft.client_vr.render.RenderPass;
+import org.vivecraft.util.VLoader;
 
 import static org.lwjgl.openvr.VRCompositor.VRCompositor_PostPresentHandoff;
 import static org.lwjgl.openvr.VRCompositor.VRCompositor_Submit;
@@ -26,10 +29,14 @@
 public class OpenVRStereoRenderer extends VRRenderer {
     private final HiddenAreaMesh[] hiddenMeshes = new HiddenAreaMesh[2];
     private final MCOpenVR openvr;
+    protected int LeftEyeTextureId = -1;
+    protected int RightEyeTextureId = -1;
+    public RenderTarget framebufferEye0;
+    public RenderTarget framebufferEye1;
 
-    public OpenVRStereoRenderer(MCVR vr) {
+    public OpenVRStereoRenderer(MCOpenVR vr) {
         super(vr);
-        this.openvr = (MCOpenVR) vr;
+        this.openvr = vr;
         hiddenMeshes[0] = HiddenAreaMesh.calloc();
         hiddenMeshes[1] = HiddenAreaMesh.calloc();
     }
@@ -85,13 +92,13 @@
         return "";
     }
 
-    public void createRenderTexture(int lwidth, int lheight) {
+    public void createRenderTexture(int lwidth, int lheight) throws RenderConfigException {
         this.LeftEyeTextureId = GlStateManager._genTexture();
         int i = GlStateManager._getInteger(GL11.GL_TEXTURE_BINDING_2D);
         RenderSystem.bindTexture(this.LeftEyeTextureId);
         RenderSystem.texParameter(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MIN_FILTER, GL11.GL_LINEAR);
         RenderSystem.texParameter(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MAG_FILTER, GL11.GL_LINEAR);
-        GlStateManager._texImage2D(GL11.GL_TEXTURE_2D, 0, GL11.GL_RGBA8, lwidth, lheight, 0, GL11.GL_RGBA, GL11.GL_INT, null);
+        GlStateManager._texImage2D(GL11.GL_TEXTURE_2D, 0, GL11.GL_RGBA8, lwidth, lheight, 0, GL11.GL_RGBA, GL11.GL_UNSIGNED_BYTE, null);
         RenderSystem.bindTexture(i);
         this.openvr.texType0.handle(this.LeftEyeTextureId);
         this.openvr.texType0.eColorSpace(VR.EColorSpace_ColorSpace_Gamma);
@@ -102,11 +109,30 @@
         RenderSystem.bindTexture(this.RightEyeTextureId);
         RenderSystem.texParameter(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MIN_FILTER, GL11.GL_LINEAR);
         RenderSystem.texParameter(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MAG_FILTER, GL11.GL_LINEAR);
-        GlStateManager._texImage2D(GL11.GL_TEXTURE_2D, 0, GL11.GL_RGBA8, lwidth, lheight, 0, GL11.GL_RGBA, GL11.GL_INT, null);
+        GlStateManager._texImage2D(GL11.GL_TEXTURE_2D, 0, GL11.GL_RGBA8, lwidth, lheight, 0, GL11.GL_RGBA, GL11.GL_UNSIGNED_BYTE, null);
         RenderSystem.bindTexture(i);
         this.openvr.texType1.handle(this.RightEyeTextureId);
         this.openvr.texType1.eColorSpace(VR.EColorSpace_ColorSpace_Gamma);
         this.openvr.texType1.eType(VR.ETextureType_TextureType_OpenGL);
+
+        ClientDataHolderVR dataholder = ClientDataHolderVR.getInstance();
+        if (this.LeftEyeTextureId == -1) {
+            throw new RenderConfigException("Failed to initialise stereo rendering plugin: " + this.getName(), Component.literal(this.getLastError()));
+        }
+
+        this.checkGLError("Render Texture setup");
+
+        if (this.framebufferEye0 == null) {
+            this.framebufferEye0 = new VRTextureTarget("L Eye", lwidth, lheight, false, false, this.LeftEyeTextureId, false, true, false);
+            dataholder.print(this.framebufferEye0.toString());
+            this.checkGLError("Left Eye framebuffer setup");
+        }
+
+        if (this.framebufferEye1 == null) {
+            this.framebufferEye1 = new VRTextureTarget("R Eye", lwidth, lheight, false, false, this.RightEyeTextureId, false, true, false);
+            dataholder.print(this.framebufferEye1.toString());
+            this.checkGLError("Right Eye framebuffer setup");
+        }
     }
 
     public boolean endFrame(RenderPass eye) {
@@ -169,6 +195,16 @@
         return true;
     }
 
+    @Override
+    public RenderTarget getLeftEyeTarget() {
+        return framebufferEye0;
+    }
+
+    @Override
+    public RenderTarget getRightEyeTarget() {
+        return framebufferEye1;
+    }
+
     public float[] getStencilMask(RenderPass eye) {
         if (this.hiddenMesheVertecies != null && (eye == RenderPass.LEFT || eye == RenderPass.RIGHT)) {
             return eye == RenderPass.LEFT ? this.hiddenMesheVertecies[0] : this.hiddenMesheVertecies[1];
@@ -192,6 +228,15 @@
     @Override
     public void destroy() {
         super.destroy();
+        if (this.framebufferEye0 != null) {
+            this.framebufferEye0.destroyBuffers();
+            this.framebufferEye0 = null;
+        }
+
+        if (this.framebufferEye1 != null) {
+            this.framebufferEye1.destroyBuffers();
+            this.framebufferEye1 = null;
+        }
         if (this.LeftEyeTextureId > -1) {
             TextureUtil.releaseTextureId(this.LeftEyeTextureId);
             this.LeftEyeTextureId = -1;
Index: common/src/main/java/org/vivecraft/client_vr/provider/openvr_lwjgl/control/VivecraftMovementInput.java
===================================================================
diff --git a/common/src/main/java/org/vivecraft/client_vr/provider/openvr_lwjgl/control/VivecraftMovementInput.java b/common/src/main/java/org/vivecraft/client_vr/provider/openvr_lwjgl/control/VivecraftMovementInput.java
deleted file mode 100644
--- a/common/src/main/java/org/vivecraft/client_vr/provider/openvr_lwjgl/control/VivecraftMovementInput.java	(revision eaec65274edbf6dec8d28b76e7403b21c6b3145b)
+++ /dev/null	(revision eaec65274edbf6dec8d28b76e7403b21c6b3145b)
@@ -1,12 +0,0 @@
-package org.vivecraft.client_vr.provider.openvr_lwjgl.control;
-
-import net.minecraft.client.KeyMapping;
-import org.vivecraft.client_vr.provider.MCVR;
-import org.vivecraft.client_vr.provider.openvr_lwjgl.VRInputAction;
-
-public class VivecraftMovementInput {
-    public static float getMovementAxisValue(KeyMapping keyBinding) {
-        VRInputAction vrinputaction = MCVR.get().getInputAction(keyBinding);
-        return Math.abs(vrinputaction.getAxis1DUseTracked());
-    }
-}
Index: common/src/main/java/org/vivecraft/client_vr/provider/openxr/MCOpenXR.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/src/main/java/org/vivecraft/client_vr/provider/openxr/MCOpenXR.java b/common/src/main/java/org/vivecraft/client_vr/provider/openxr/MCOpenXR.java
new file mode 100644
--- /dev/null	(revision a1131575d6931b12d3cb0b9f8a519b861bc5ca4c)
+++ b/common/src/main/java/org/vivecraft/client_vr/provider/openxr/MCOpenXR.java	(revision a1131575d6931b12d3cb0b9f8a519b861bc5ca4c)
@@ -0,0 +1,1479 @@
+package org.vivecraft.client_vr.provider.openxr;
+
+import com.mojang.blaze3d.platform.Window;
+import net.minecraft.client.KeyMapping;
+import net.minecraft.client.Minecraft;
+import net.minecraft.util.Mth;
+import net.minecraft.world.phys.Vec3;
+import org.apache.commons.lang3.tuple.Pair;
+import org.joml.Vector2f;
+import org.lwjgl.PointerBuffer;
+import org.lwjgl.glfw.*;
+import org.lwjgl.opengl.GL11;
+import org.lwjgl.opengl.GL21;
+import org.lwjgl.opengl.GL30;
+import org.lwjgl.opengl.GL31;
+import org.lwjgl.openxr.*;
+import org.lwjgl.system.MemoryStack;
+import org.lwjgl.system.Platform;
+import org.lwjgl.system.Struct;
+import org.lwjgl.system.linux.X11;
+import org.lwjgl.system.windows.User32;
+import org.vivecraft.client.VivecraftVRMod;
+import org.vivecraft.client.utils.Utils;
+import org.vivecraft.client_vr.ClientDataHolderVR;
+import org.vivecraft.client_vr.gameplay.screenhandlers.KeyboardHandler;
+import org.vivecraft.client_vr.gameplay.screenhandlers.RadialHandler;
+import org.vivecraft.client_vr.provider.ControllerType;
+import org.vivecraft.client_vr.provider.InputSimulator;
+import org.vivecraft.client_vr.provider.MCVR;
+import org.vivecraft.client_vr.provider.VRRenderer;
+import org.vivecraft.client_vr.provider.control.VRInputAction;
+import org.vivecraft.client_vr.provider.control.VRInputActionSet;
+import org.vivecraft.client_vr.render.RenderConfigException;
+import org.vivecraft.client_vr.render.RenderPass;
+import org.vivecraft.client_vr.settings.VRSettings;
+import org.vivecraft.client_xr.render_pass.RenderPassManager;
+import org.vivecraft.common.utils.lwjgl.Vector3f;
+import org.vivecraft.common.utils.math.Matrix4f;
+import org.vivecraft.common.utils.math.Vector3;
+import org.vivecraft.util.VLoader;
+
+import java.nio.ByteBuffer;
+import java.nio.IntBuffer;
+import java.nio.LongBuffer;
+import java.util.*;
+
+import static org.lwjgl.opengl.GLX13.*;
+import static org.lwjgl.system.MemoryStack.*;
+import static org.lwjgl.system.MemoryUtil.*;
+
+public class MCOpenXR extends MCVR {
+
+    private static MCOpenXR ome;
+    public XrInstance instance;
+    public XrSession session;
+    public XrSpace xrAppSpace;
+    public XrSpace xrViewSpace;
+    public XrSwapchain swapchain;
+    public final XrEventDataBuffer eventDataBuffer = XrEventDataBuffer.calloc();
+    public long time;
+    private boolean tried;
+    private long systemID;
+    public XrView.Buffer viewBuffer;
+    public int width;
+    public int height;
+    //TODO either move to MCVR, Or make special for OpenXR holding the instance itself.
+    private final Map<VRInputActionSet, Long> actionSetHandles = new EnumMap<>(VRInputActionSet.class);
+    //TODO Move to MCVR
+    private  XrActiveActionSet.Buffer activeActionSetsBuffer;
+    private boolean isActive;
+    private final HashMap<String, Long> paths = new HashMap<>();
+    private final long[] grip = new long[2];
+    private final long[] aim = new long[2];
+    private final XrSpace[] gripSpace = new XrSpace[2];
+    private final XrSpace[] aimSpace = new XrSpace[2];
+    public static final XrPosef POSE_IDENTITY = XrPosef.calloc().set(
+        XrQuaternionf.calloc().set(0, 0, 0, 1),
+        XrVector3f.calloc()
+    );
+    public boolean shouldRender = true;
+    public long[] haptics = new long[2];
+    public String systemName;
+
+
+    public MCOpenXR(Minecraft mc, ClientDataHolderVR dh) {
+        super(mc, dh, VivecraftVRMod.INSTANCE);
+        ome = this;
+        this.hapticScheduler = new OpenXRHapticSchedular();
+
+    }
+
+    @Override
+    public String getName() {
+        return "OpenXR";
+    }
+
+    @Override
+    public String getID() {
+        return "openxr";
+    }
+
+    @Override
+    public void destroy() {
+        int error;
+        //Not sure if we need the action sets one here, as we are shutting down
+        for (Long inputActionSet : actionSetHandles.values()){
+            error = XR10.xrDestroyActionSet(new XrActionSet(inputActionSet, instance));
+            logError(error, "xrDestroyActionSet", "");
+        }
+        if (swapchain != null) {
+            error = XR10.xrDestroySwapchain(swapchain);
+            logError(error, "xrDestroySwapchain", "");
+        }
+        if (viewBuffer != null) {
+            viewBuffer.close();
+        }
+        if (xrAppSpace != null) {
+            error = XR10.xrDestroySpace(xrAppSpace);
+            logError(error, "xrDestroySpace", "xrAppSpace");
+        }
+        if (xrViewSpace != null) {
+            error = XR10.xrDestroySpace(xrViewSpace);
+            logError(error, "xrDestroySpace", "xrViewSpace");
+        }
+        if (session != null){
+            error = XR10.xrDestroySession(session);
+            logError(error, "xrDestroySession", "");
+        }
+        if (instance != null){
+            error = XR10.xrDestroyInstance(instance);
+            logError(error, "xrDestroyInstance", "");
+        }
+        eventDataBuffer.close();
+    }
+
+    @Override
+    protected void triggerBindingHapticPulse(KeyMapping binding, int duration) {
+        ControllerType controllertype = this.findActiveBindingControllerType(binding);
+
+        if (controllertype != null) {
+            this.triggerHapticPulse(controllertype, duration);
+        }
+    }
+
+    @Override
+    protected ControllerType findActiveBindingControllerType(KeyMapping binding) {
+        if (!this.inputInitialized) {
+            return null;
+        } else {
+            long path = this.getInputAction(binding).getLastOrigin();
+            try (MemoryStack stack = MemoryStack.stackPush()) {
+                IntBuffer buf = stack.callocInt(1);
+                int error = XR10.xrPathToString(instance, path, buf, null);
+                logError(error, "xrPathToString", "get string length for", binding.getName());
+
+                int size = buf.get();
+                if (size <= 0) {
+                    return null;
+                }
+
+                buf = stack.callocInt(size);
+                ByteBuffer byteBuffer = stack.calloc(size);
+                error = XR10.xrPathToString(instance, path, buf, byteBuffer);
+                logError(error, "xrPathToString", "get string for", binding.getName());
+                byte[] bytes = new byte[byteBuffer.remaining()];
+                byteBuffer.get(bytes);
+                String name = new String(bytes);
+                if (name.contains("right")) {
+                    return ControllerType.RIGHT;
+                }
+                return ControllerType.LEFT;
+            }
+        }
+    }
+
+    @Override
+    public void poll(long var1) {
+        if (this.initialized) {
+            this.mc.getProfiler().push("events");
+            //pollVREvents();
+
+            if (!this.dh.vrSettings.seated) {
+                this.mc.getProfiler().popPush("controllers");
+                this.mc.getProfiler().push("gui");
+
+                if (this.mc.screen == null && this.dh.vrSettings.vrTouchHotbar) {
+                    VRSettings vrsettings = this.dh.vrSettings;
+
+                    if (this.dh.vrSettings.vrHudLockMode != VRSettings.HUDLock.HEAD && this.hudPopup) {
+                        this.processHotbar();
+                    }
+                }
+
+                this.mc.getProfiler().pop();
+            }
+            this.mc.getProfiler().popPush("updatePose/Vsync");
+            this.updatePose();
+            this.mc.getProfiler().popPush("processInputs");
+            this.processInputs();
+            this.mc.getProfiler().popPush("hmdSampling");
+            this.hmdSampling();
+            this.mc.getProfiler().pop();
+        }
+    }
+
+    private void updatePose() {
+        RenderPassManager.setGUIRenderPass();
+
+        if (mc == null) {
+            return;
+        }
+        try (MemoryStack stack = MemoryStack.stackPush()) {
+            XrFrameState frameState = XrFrameState.calloc(stack).type(XR10.XR_TYPE_FRAME_STATE);
+
+            int error = XR10.xrWaitFrame(
+                session,
+                XrFrameWaitInfo.calloc(stack).type(XR10.XR_TYPE_FRAME_WAIT_INFO),
+                frameState);
+            logError(error, "xrWaitFrame", "");
+
+            time = frameState.predictedDisplayTime();
+            this.shouldRender = frameState.shouldRender();
+
+            error = XR10.xrBeginFrame(
+                session,
+                XrFrameBeginInfo.calloc(stack).type(XR10.XR_TYPE_FRAME_BEGIN_INFO));
+            logError(error, "xrBeginFrame", "");
+
+
+            XrViewState viewState = XrViewState.calloc(stack).type(XR10.XR_TYPE_VIEW_STATE);
+            IntBuffer intBuf = stack.callocInt(1);
+
+            XrViewLocateInfo viewLocateInfo = XrViewLocateInfo.calloc(stack);
+            viewLocateInfo.set(XR10.XR_TYPE_VIEW_LOCATE_INFO,
+                0,
+                XR10.XR_VIEW_CONFIGURATION_TYPE_PRIMARY_STEREO,
+                frameState.predictedDisplayTime(),
+                xrAppSpace
+            );
+
+            error = XR10.xrLocateViews(session, viewLocateInfo, viewState, intBuf, viewBuffer);
+            logError(error, "xrLocateViews", "");
+
+            XrSpaceLocation space_location = XrSpaceLocation.calloc(stack).type(XR10.XR_TYPE_SPACE_LOCATION);
+
+            //HMD pose
+            error = XR10.xrLocateSpace(xrViewSpace, xrAppSpace, time, space_location);
+            logError(error, "xrLocateSpace", "xrViewSpace");
+            if (error >= 0) {
+                OpenXRUtil.openXRPoseToMarix(space_location.pose(), this.hmdPose);
+                OpenXRUtil.openXRPoseToMarix(space_location.pose().orientation(), this.hmdRotation);
+
+                Vec3 vec3 = new Vec3(space_location.pose().position$().x(), space_location.pose().position$().y(), space_location.pose().position$().z());
+                this.hmdHistory.add(vec3);
+                Vector3 vector3 = this.hmdRotation.transform(new Vector3(0.0F, -0.1F, 0.1F));
+                this.hmdPivotHistory.add(new Vec3((double) vector3.getX() + vec3.x, (double) vector3.getY() + vec3.y, (double) vector3.getZ() + vec3.z));
+                headIsTracking = true;
+            } else {
+                headIsTracking = false;
+            }
+
+            //Eye positions
+            OpenXRUtil.openXRPoseToMarix(viewBuffer.get(0).pose(), this.hmdPoseLeftEye);
+            OpenXRUtil.openXRPoseToMarix(viewBuffer.get(1).pose(), this.hmdPoseRightEye);
+
+            //reverse
+            if (this.dh.vrSettings.reverseHands) {
+                XrSpace temp = gripSpace[0];
+                gripSpace[0] = gripSpace[1];
+                gripSpace[1] = temp;
+                temp = aimSpace[0];
+                aimSpace[0] = aimSpace[1];
+                aimSpace[1] = temp;
+            }
+
+            //Controller aim and grip poses
+            error = XR10.xrLocateSpace(gripSpace[0], xrAppSpace, time, space_location);
+            logError(error, "xrLocateSpace", "gripSpace[0]");
+            if (error >= 0) {
+                OpenXRUtil.openXRPoseToMarix(space_location.pose().orientation(), this.handRotation[0]);
+            }
+
+            error = XR10.xrLocateSpace(gripSpace[1], xrAppSpace, time, space_location);
+            logError(error, "xrLocateSpace", "gripSpace[1]");
+            if (error >= 0) {
+                OpenXRUtil.openXRPoseToMarix(space_location.pose().orientation(), this.handRotation[1]);
+            }
+
+            error = XR10.xrLocateSpace(aimSpace[0], xrAppSpace, time, space_location);
+            logError(error, "xrLocateSpace", "aimSpace[0]");
+            if (error >= 0) {
+                OpenXRUtil.openXRPoseToMarix(space_location.pose(), this.controllerPose[0]);
+                OpenXRUtil.openXRPoseToMarix(space_location.pose().orientation(), this.controllerRotation[0]);
+                this.aimSource[0] = new Vec3(space_location.pose().position$().x(), space_location.pose().position$().y(), space_location.pose().position$().z());
+                this.controllerHistory[0].add(this.getAimSource(0));
+                this.controllerForwardHistory[0].add(this.getAimSource(0));
+                Vec3 vec33 = this.controllerRotation[0].transform(this.up).toVector3d();
+                this.controllerUpHistory[0].add(vec33);
+                this.controllerTracking[0] = true;
+            } else {
+                this.controllerTracking[0] = false;
+            }
+
+            error = XR10.xrLocateSpace(aimSpace[1], xrAppSpace, time, space_location);
+            logError(error, "xrLocateSpace", "aimSpace[1]");
+            if (error >= 0) {
+                OpenXRUtil.openXRPoseToMarix(space_location.pose(), this.controllerPose[1]);
+                OpenXRUtil.openXRPoseToMarix(space_location.pose().orientation(), this.controllerRotation[1]);
+                this.aimSource[1] = new Vec3(space_location.pose().position$().x(), space_location.pose().position$().y(), space_location.pose().position$().z());
+                this.controllerHistory[1].add(this.getAimSource(1));
+                this.controllerForwardHistory[1].add(this.getAimSource(1));
+                Vec3 vec32 = this.controllerRotation[1].transform(this.up).toVector3d();
+                this.controllerUpHistory[1].add(vec32);
+                this.controllerTracking[1] = true;
+            } else {
+                this.controllerTracking[1] = false;
+            }
+
+            //TODO merge with updateAim so it's one method
+            if (this.dh.vrSettings.seated) {
+                this.controllerPose[0] = this.hmdPose.inverted().inverted();
+                this.controllerPose[1] = this.hmdPose.inverted().inverted();
+                this.handRotation[0] = hmdRotation;
+                this.handRotation[1] = hmdRotation;
+                this.controllerRotation[0] = hmdRotation;
+                this.controllerRotation[1] = hmdRotation;
+                this.aimSource[1] = this.getCenterEyePosition();
+                this.aimSource[0] = this.getCenterEyePosition();
+
+                if (this.mc.screen == null) {
+                    Vec3 vec31 = this.getAimVector(1);
+                    org.vivecraft.common.utils.lwjgl.Matrix4f matrix4f = new org.vivecraft.common.utils.lwjgl.Matrix4f();
+                    float f = 110.0F;
+                    float f1 = 180.0F;
+                    double d0 = this.mc.mouseHandler.xpos() / (double) this.mc.getWindow().getScreenWidth() * (double) f - (double) (f / 2.0F);
+                    int i = this.mc.getWindow().getScreenHeight();
+
+                    if (i % 2 != 0) {
+                        --i;
+                    }
+
+                    double d1 = -this.mc.mouseHandler.ypos() / (double) i * (double) f1 + (double) (f1 / 2.0F);
+                    double d2 = -d1;
+
+                    if (this.mc.isWindowActive()) {
+                        float f2 = this.dh.vrSettings.keyholeX;
+                        float f3 = 20.0F * this.dh.vrSettings.xSensitivity;
+                        int j = (int) ((double) (-f2 + f / 2.0F) * (double) this.mc.getWindow().getScreenWidth() / (double) f) + 1;
+                        int k = (int) ((double) (f2 + f / 2.0F) * (double) this.mc.getWindow().getScreenWidth() / (double) f) - 1;
+                        float f4 = ((float) Math.abs(d0) - f2) / (f / 2.0F - f2);
+                        double d3 = this.mc.mouseHandler.xpos();
+
+                        if (d0 < (double) (-f2)) {
+                            this.seatedRot += f3 * f4;
+                            this.seatedRot %= 360.0F;
+                            this.hmdForwardYaw = (float) Math.toDegrees(Math.atan2(vec31.x, vec31.z));
+                            d3 = j;
+                            d0 = -f2;
+                        } else if (d0 > (double) f2) {
+                            this.seatedRot -= f3 * f4;
+                            this.seatedRot %= 360.0F;
+                            this.hmdForwardYaw = (float) Math.toDegrees(Math.atan2(vec31.x, vec31.z));
+                            d3 = k;
+                            d0 = f2;
+                        }
+
+                        double d4 = 0.5D * (double) this.dh.vrSettings.ySensitivity;
+                        d2 = (double) this.aimPitch + d1 * d4;
+                        d2 = Mth.clamp(d2, -89.9D, 89.9D);
+                        InputSimulator.setMousePos(d3, i / 2);
+                        GLFW.glfwSetCursorPos(this.mc.getWindow().getWindow(), d3, i / 2);
+                        matrix4f.rotate((float) Math.toRadians(-d2), new Vector3f(1.0F, 0.0F, 0.0F));
+                        matrix4f.rotate((float) Math.toRadians(-180.0D + d0 - (double) this.hmdForwardYaw), new Vector3f(0.0F, 1.0F, 0.0F));
+                    }
+
+                    this.controllerRotation[0].M[0][0] = matrix4f.m00;
+                    this.controllerRotation[0].M[0][1] = matrix4f.m01;
+                    this.controllerRotation[0].M[0][2] = matrix4f.m02;
+                    this.controllerRotation[0].M[1][0] = matrix4f.m10;
+                    this.controllerRotation[0].M[1][1] = matrix4f.m11;
+                    this.controllerRotation[0].M[1][2] = matrix4f.m12;
+                    this.controllerRotation[0].M[2][0] = matrix4f.m20;
+                    this.controllerRotation[0].M[2][1] = matrix4f.m21;
+                    this.controllerRotation[0].M[2][2] = matrix4f.m22;
+
+                    this.handRotation[0].M[0][0] = matrix4f.m00;
+                    this.handRotation[0].M[0][1] = matrix4f.m01;
+                    this.handRotation[0].M[0][2] = matrix4f.m02;
+                    this.handRotation[0].M[1][0] = matrix4f.m10;
+                    this.handRotation[0].M[1][1] = matrix4f.m11;
+                    this.handRotation[0].M[1][2] = matrix4f.m12;
+                    this.handRotation[0].M[2][0] = matrix4f.m20;
+                    this.handRotation[0].M[2][1] = matrix4f.m21;
+                    this.handRotation[0].M[2][2] = matrix4f.m22;
+                }
+            }
+            Vec3 vec32 = this.getAimVector(0);
+            this.aimPitch = (float) Math.toDegrees(Math.asin(vec32.y / vec32.length()));
+
+            if (this.inputInitialized) {
+                this.mc.getProfiler().push("updateActionState");
+
+                if (this.updateActiveActionSets()) {
+                    XrActionsSyncInfo syncInfo = XrActionsSyncInfo.calloc(stack)
+                        .type(XR10.XR_TYPE_ACTIONS_SYNC_INFO)
+                        .activeActionSets(activeActionSetsBuffer);
+                    error = XR10.xrSyncActions(session, syncInfo);
+                    logError(error, "xrSyncActions", "");
+                }
+
+                this.inputActions.values().forEach(this::readNewData);
+
+                //TODO Not needed it seems? Poses come from the action space
+                XrActionSet actionSet = new XrActionSet(this.actionSetHandles.get(VRInputActionSet.GLOBAL), instance);
+                this.readPoseData(this.grip[0], actionSet);
+                this.readPoseData(this.grip[1], actionSet);
+                this.readPoseData(this.aim[0], actionSet);
+                this.readPoseData(this.aim[1], actionSet);
+
+                this.mc.getProfiler().pop();
+            }
+        }
+    }
+
+    @Override
+    public Vec3 getEyePosition(RenderPass eye) {
+        org.vivecraft.common.utils.math.Matrix4f matrix4f = this.hmdPoseRightEye;
+
+        if (eye == RenderPass.LEFT) {
+            matrix4f = this.hmdPoseLeftEye;
+        } else if (eye == RenderPass.RIGHT) {
+            matrix4f = this.hmdPoseRightEye;
+        } else {
+            matrix4f = null;
+        }
+
+        if (matrix4f == null) {
+            org.vivecraft.common.utils.math.Matrix4f matrix4f2 = this.hmdPose;
+            Vector3 vector31 = Utils.convertMatrix4ftoTranslationVector(matrix4f2);
+
+            if (this.dh.vrSettings.seated || this.dh.vrSettings.allowStandingOriginOffset) {
+                if (this.dh.vr.isHMDTracking()) {
+                    vector31 = vector31.add(this.dh.vrSettings.originOffset);
+                }
+            }
+
+            return vector31.toVector3d();
+        } else {
+            Vector3 vector3 = Utils.convertMatrix4ftoTranslationVector(matrix4f);
+
+            if (this.dh.vrSettings.seated || this.dh.vrSettings.allowStandingOriginOffset) {
+                if (this.dh.vr.isHMDTracking()) {
+                    vector3 = vector3.add(this.dh.vrSettings.originOffset);
+                }
+            }
+
+            return vector3.toVector3d();
+        }
+    }
+
+    @Override
+    public org.vivecraft.common.utils.math.Matrix4f getEyeRotation(RenderPass eye) {
+        org.vivecraft.common.utils.math.Matrix4f matrix4f;
+
+        if (eye == RenderPass.LEFT) {
+            matrix4f = this.hmdPoseLeftEye;
+        } else if (eye == RenderPass.RIGHT) {
+            matrix4f = this.hmdPoseRightEye;
+        } else {
+            matrix4f = null;
+        }
+
+        if (matrix4f != null) {
+            org.vivecraft.common.utils.math.Matrix4f matrix4f1 = new org.vivecraft.common.utils.math.Matrix4f();
+            matrix4f1.M[0][0] = matrix4f.M[0][0];
+            matrix4f1.M[0][1] = matrix4f.M[0][1];
+            matrix4f1.M[0][2] = matrix4f.M[0][2];
+            matrix4f1.M[0][3] = 0.0F;
+            matrix4f1.M[1][0] = matrix4f.M[1][0];
+            matrix4f1.M[1][1] = matrix4f.M[1][1];
+            matrix4f1.M[1][2] = matrix4f.M[1][2];
+            matrix4f1.M[1][3] = 0.0F;
+            matrix4f1.M[2][0] = matrix4f.M[2][0];
+            matrix4f1.M[2][1] = matrix4f.M[2][1];
+            matrix4f1.M[2][2] = matrix4f.M[2][2];
+            matrix4f1.M[2][3] = 0.0F;
+            matrix4f1.M[3][0] = 0.0F;
+            matrix4f1.M[3][1] = 0.0F;
+            matrix4f1.M[3][2] = 0.0F;
+            matrix4f1.M[3][3] = 1.0F;
+            return matrix4f1;
+        } else {
+            return this.hmdRotation;
+        }
+    }
+
+    public void readNewData(VRInputAction action) {
+        String s = action.type;
+
+        switch (s) {
+            case "boolean":
+                if (action.isHanded()) {
+                    for (ControllerType controllertype1 : ControllerType.values()) {
+                        this.readBoolean(action, controllertype1);
+                    }
+                } else {
+                    this.readBoolean(action, null);
+                }
+
+                break;
+
+            case "vector1":
+                if (action.isHanded()) {
+                    for (ControllerType controllertype : ControllerType.values()) {
+                        this.readFloat(action, controllertype);
+                    }
+                } else {
+                    this.readFloat(action, null);
+                }
+                break;
+
+            case "vector2":
+                if (action.isHanded()) {
+                    for (ControllerType controllertype : ControllerType.values()) {
+                        this.readVecData(action, controllertype);
+                    }
+                } else {
+                    this.readVecData(action, null);
+                }
+                break;
+
+            case "vector3":
+
+        }
+    }
+
+    private void readBoolean(VRInputAction action, ControllerType hand) {
+        int i = 0;
+
+        if (hand != null) {
+            i = hand.ordinal();
+        }
+        try (MemoryStack stack = MemoryStack.stackPush()){
+            XrActionStateGetInfo info = XrActionStateGetInfo.calloc(stack);
+            info.type(XR10.XR_TYPE_ACTION_STATE_GET_INFO);
+            info.action(new XrAction(action.handle, new XrActionSet(actionSetHandles.get(action.actionSet), instance)));
+            XrActionStateBoolean state = XrActionStateBoolean.calloc(stack).type(XR10.XR_TYPE_ACTION_STATE_BOOLEAN);
+            int error = XR10.xrGetActionStateBoolean(session, info, state);
+            logError(error, "xrGetActionStateBoolean",  action.name);
+
+            action.digitalData[i].state = state.currentState();
+            action.digitalData[i].isActive = state.isActive();
+            action.digitalData[i].isChanged = state.changedSinceLastSync();
+            action.digitalData[i].activeOrigin = getOrigins(action).get(0);
+        }
+    }
+
+    private void readFloat(VRInputAction action, ControllerType hand) {
+        int i = 0;
+
+        if (hand != null) {
+            i = hand.ordinal();
+        }
+        try (MemoryStack stack = MemoryStack.stackPush()){
+            XrActionStateGetInfo info = XrActionStateGetInfo.calloc(stack);
+            info.type(XR10.XR_TYPE_ACTION_STATE_GET_INFO);
+            info.action(new XrAction(action.handle, new XrActionSet(actionSetHandles.get(action.actionSet), instance)));
+            XrActionStateFloat state = XrActionStateFloat.calloc(stack).type(XR10.XR_TYPE_ACTION_STATE_FLOAT);
+            int error = XR10.xrGetActionStateFloat(session, info, state);
+            logError(error, "xrGetActionStateFloat",  action.name);
+
+            action.analogData[i].deltaX = action.analogData[i].x - state.currentState();
+            action.analogData[i].x = state.currentState();
+            action.analogData[i].activeOrigin = getOrigins(action).get(0);
+            action.analogData[i].isActive = state.isActive();
+            action.analogData[i].isChanged = state.changedSinceLastSync();
+        }
+    }
+
+    private void readVecData(VRInputAction action, ControllerType hand) {
+        int i = 0;
+
+        if (hand != null) {
+            i = hand.ordinal();
+        }
+        try (MemoryStack stack = MemoryStack.stackPush()){
+            XrActionStateGetInfo info = XrActionStateGetInfo.calloc(stack);
+            info.type(XR10.XR_TYPE_ACTION_STATE_GET_INFO);
+            info.action(new XrAction(action.handle, new XrActionSet(actionSetHandles.get(action.actionSet), instance)));
+            XrActionStateVector2f state = XrActionStateVector2f.calloc(stack).type(XR10.XR_TYPE_ACTION_STATE_VECTOR2F);
+            int error = XR10.xrGetActionStateVector2f(session, info, state);
+            logError(error, "xrGetActionStateVector2f",  action.name);
+
+            action.analogData[i].deltaX = action.analogData[i].x - state.currentState().x();
+            action.analogData[i].deltaY = action.analogData[i].y - state.currentState().y();
+            action.analogData[i].x = state.currentState().x();
+            action.analogData[i].y = state.currentState().y();
+            action.analogData[i].activeOrigin = getOrigins(action).get(0);
+            action.analogData[i].isActive = state.isActive();
+            action.analogData[i].isChanged = state.changedSinceLastSync();
+        }
+    }
+
+    private void readPoseData(Long action, XrActionSet set) {
+        try (MemoryStack stack = MemoryStack.stackPush()){
+            XrActionStateGetInfo info = XrActionStateGetInfo.calloc(stack);
+            info.type(XR10.XR_TYPE_ACTION_STATE_GET_INFO);
+            info.action(new XrAction(action, set));
+            XrActionStatePose state = XrActionStatePose.calloc(stack).type(XR10.XR_TYPE_ACTION_STATE_POSE);
+            int error = XR10.xrGetActionStatePose(session, info, state);
+            logError(error, "xrGetActionStatePose",  "");
+        }
+    }
+
+    private boolean updateActiveActionSets() {
+        ArrayList<VRInputActionSet> arraylist = new ArrayList<>();
+        arraylist.add(VRInputActionSet.GLOBAL);
+
+        // we are always modded
+        arraylist.add(VRInputActionSet.MOD);
+
+        arraylist.add(VRInputActionSet.MIXED_REALITY);
+        arraylist.add(VRInputActionSet.TECHNICAL);
+
+        if (this.mc.screen == null) {
+            arraylist.add(VRInputActionSet.INGAME);
+            arraylist.add(VRInputActionSet.CONTEXTUAL);
+        } else {
+            arraylist.add(VRInputActionSet.GUI);
+            if (ClientDataHolderVR.getInstance().vrSettings.ingameBindingsInGui) {
+                arraylist.add(VRInputActionSet.INGAME);
+            }
+        }
+
+        if (KeyboardHandler.Showing || RadialHandler.isShowing()) {
+            arraylist.add(VRInputActionSet.KEYBOARD);
+        }
+
+        if (this.activeActionSetsBuffer == null) {
+            activeActionSetsBuffer = XrActiveActionSet.calloc(arraylist.size());
+        } else if (activeActionSetsBuffer.capacity() != arraylist.size()) {
+            activeActionSetsBuffer.close();
+            activeActionSetsBuffer = XrActiveActionSet.calloc(arraylist.size());
+        }
+
+        for (int i = 0; i < arraylist.size(); ++i) {
+            VRInputActionSet vrinputactionset = arraylist.get(i);
+            activeActionSetsBuffer.get(i).set(new XrActionSet(this.getActionSetHandle(vrinputactionset), instance), NULL);
+        }
+
+        return !arraylist.isEmpty();
+    }
+
+    private void updateControllerPose(int controller, long actionHandle) {
+
+    }
+
+    long getActionSetHandle(VRInputActionSet actionSet) {
+        return this.actionSetHandles.get(actionSet);
+    }
+
+    private void pollVREvents() {
+        while (true) {
+            eventDataBuffer.clear();
+            eventDataBuffer.type(XR10.XR_TYPE_EVENT_DATA_BUFFER);
+            int error = XR10.xrPollEvent(instance, eventDataBuffer);
+            logError(error, "xrPollEvent",  "");
+            if (error != XR10.XR_SUCCESS) {
+                break;
+            }
+            XrEventDataBaseHeader event = XrEventDataBaseHeader.create(eventDataBuffer.address());
+
+            switch (event.type()) {
+                case XR10.XR_TYPE_EVENT_DATA_INSTANCE_LOSS_PENDING -> {
+                    XrEventDataInstanceLossPending instanceLossPending = XrEventDataInstanceLossPending.create(event.address());
+                }
+                case XR10.XR_TYPE_EVENT_DATA_SESSION_STATE_CHANGED -> {
+                    this.sessionChanged(XrEventDataSessionStateChanged.create(event.address()));
+                }
+                case XR10.XR_TYPE_EVENT_DATA_INTERACTION_PROFILE_CHANGED -> {
+                }
+                case XR10.XR_TYPE_EVENT_DATA_REFERENCE_SPACE_CHANGE_PENDING -> {
+                }
+                default -> {
+                }
+            }
+        }
+    }
+
+    private void sessionChanged(XrEventDataSessionStateChanged xrEventDataSessionStateChanged) {
+        int state = xrEventDataSessionStateChanged.state();
+
+        switch (state) {
+            case XR10.XR_SESSION_STATE_READY: {
+                try (MemoryStack stack = MemoryStack.stackPush()){
+                    XrSessionBeginInfo sessionBeginInfo = XrSessionBeginInfo.calloc(stack);
+                    sessionBeginInfo.type(XR10.XR_TYPE_SESSION_BEGIN_INFO);
+                    sessionBeginInfo.next(NULL);
+                    sessionBeginInfo.primaryViewConfigurationType(XR10.XR_VIEW_CONFIGURATION_TYPE_PRIMARY_STEREO);
+
+                    int error = XR10.xrBeginSession(session, sessionBeginInfo);
+                    logError(error, "xrBeginSession",  "XR_SESSION_STATE_READY");
+                }
+                this.isActive = true;
+                break;
+            }
+            case XR10.XR_SESSION_STATE_STOPPING: {
+                this.isActive = false;
+                int error = XR10.xrEndSession(session);
+                logError(error, "xrEndSession",  "XR_SESSION_STATE_STOPPING");
+            }
+            case XR10.XR_SESSION_STATE_VISIBLE, XR10.XR_SESSION_STATE_FOCUSED: {
+                this.isActive = true;
+                break;
+            }
+            case XR10.XR_SESSION_STATE_EXITING, XR10.XR_SESSION_STATE_IDLE, XR10.XR_SESSION_STATE_SYNCHRONIZED: {
+                this.isActive = false;
+                break;
+            }
+            case XR10.XR_SESSION_STATE_LOSS_PENDING: {
+                break;
+            }
+            default:
+                break;
+        }
+    }
+
+    @Override
+    public Vector2f getPlayAreaSize() {
+        try (MemoryStack stack = MemoryStack.stackPush()) {
+            XrExtent2Df vec = XrExtent2Df.calloc(stack);
+            int error = XR10.xrGetReferenceSpaceBoundsRect(session, XR10.XR_REFERENCE_SPACE_TYPE_STAGE, vec);
+            logError(error, "xrGetReferenceSpaceBoundsRect",  "");
+            return new Vector2f(vec.width(), vec.height());
+        }
+    }
+
+    @Override
+    public boolean init() {
+        if (this.initialized) {
+            return true;
+        } else if (this.tried) {
+            return this.initialized;
+        } else {
+            tried = true;
+            this.mc = Minecraft.getInstance();
+            try {
+                this.initializeOpenXRInstance();
+                this.initializeOpenXRSession();
+                this.initializeOpenXRSpace();
+                this.initializeOpenXRSwapChain();
+            } catch (Exception e) {
+                e.printStackTrace();
+                this.initSuccess = false;
+                this.initStatus = e.getLocalizedMessage();
+                return false;
+            }
+
+            //TODO Seated when no controllers
+
+            System.out.println("OpenXR initialized & VR connected.");
+            this.deviceVelocity = new Vec3[64];
+
+            for (int i = 0; i < this.poseMatrices.length; ++i) {
+                this.poseMatrices[i] = new Matrix4f();
+                this.deviceVelocity[i] = new Vec3(0.0D, 0.0D, 0.0D);
+            }
+
+            this.initialized = true;
+            return true;
+        }
+    }
+
+    private void initializeOpenXRInstance() {
+        try (MemoryStack stack = MemoryStack.stackPush()) {
+            // TODO: Use the right struct, this works for now as the sizes are the same
+            XrInstanceCreateInfoAndroidKHR loaderInitInfo = XrInstanceCreateInfoAndroidKHR.calloc(stack).set(
+                1000089000, // XR_TYPE_LOADER_INIT_INFO_ANDROID_KHR
+                0,
+                VLoader.getJVMPtr(),
+                VLoader.getActivityPtr()
+            );
+            KHRLoaderInit.xrInitializeLoaderKHR(XrLoaderInitInfoBaseHeaderKHR.create(loaderInitInfo.address()));
+
+            //Check extensions
+            IntBuffer numExtensions = stack.callocInt(1);
+            int error = XR10.xrEnumerateInstanceExtensionProperties((ByteBuffer) null, numExtensions, null);
+            logError(error, "xrEnumerateInstanceExtensionProperties",  "get count");
+
+            XrExtensionProperties.Buffer properties = new XrExtensionProperties.Buffer(
+                bufferStack(numExtensions.get(0), XrExtensionProperties.SIZEOF, XR10.XR_TYPE_EXTENSION_PROPERTIES)
+            );
+
+            //Load extensions
+            error = XR10.xrEnumerateInstanceExtensionProperties((ByteBuffer) null, numExtensions, properties);
+            logError(error, "xrEnumerateInstanceExtensionProperties",  "get extensions");
+
+            //get needed extensions
+            boolean missingOpenGL = true;
+            PointerBuffer extensions = stack.callocPointer(3);
+            while (properties.hasRemaining()) {
+                XrExtensionProperties prop = properties.get();
+                String extensionName = prop.extensionNameString();
+                if (extensionName.equals(KHROpenGLESEnable.XR_KHR_OPENGL_ES_ENABLE_EXTENSION_NAME)) {
+                    missingOpenGL = false;
+                    extensions.put(memAddress(stackUTF8(KHROpenGLESEnable.XR_KHR_OPENGL_ES_ENABLE_EXTENSION_NAME)));
+                }
+                if (extensionName.equals(EXTHPMixedRealityController.XR_EXT_HP_MIXED_REALITY_CONTROLLER_EXTENSION_NAME)) {
+                    extensions.put(memAddress(stackUTF8(EXTHPMixedRealityController.XR_EXT_HP_MIXED_REALITY_CONTROLLER_EXTENSION_NAME)));
+                }
+                if (extensionName.equals(HTCViveCosmosControllerInteraction.XR_HTC_VIVE_COSMOS_CONTROLLER_INTERACTION_EXTENSION_NAME)) {
+                    extensions.put(memAddress(stackUTF8(HTCViveCosmosControllerInteraction.XR_HTC_VIVE_COSMOS_CONTROLLER_INTERACTION_EXTENSION_NAME)));
+                }
+                if (extensionName.equals(KHRAndroidCreateInstance.XR_KHR_ANDROID_CREATE_INSTANCE_EXTENSION_NAME)) {
+                    extensions.put(memAddress(stackUTF8(KHRAndroidCreateInstance.XR_KHR_ANDROID_CREATE_INSTANCE_EXTENSION_NAME)));
+                }
+            }
+
+            if (missingOpenGL) {
+                throw new RuntimeException("OpenXR runtime does not support OpenGLES, Are you on a PC?");
+            }
+
+            //Create APP info
+            XrApplicationInfo applicationInfo = XrApplicationInfo.calloc(stack);
+            applicationInfo.apiVersion(XR10.XR_CURRENT_API_VERSION);
+            applicationInfo.applicationName(stack.UTF8("Vivecraft"));
+            applicationInfo.applicationVersion(1);
+
+            XrInstanceCreateInfoAndroidKHR androidCreateInfo = XrInstanceCreateInfoAndroidKHR.calloc(stack).set(
+                KHRAndroidCreateInstance.XR_TYPE_INSTANCE_CREATE_INFO_ANDROID_KHR,
+                NULL,
+                VLoader.getJVMPtr(),
+                VLoader.getActivityPtr()
+            );
+
+            //Create instance info
+            XrInstanceCreateInfo createInfo = XrInstanceCreateInfo.calloc(stack);
+            createInfo.type(XR10.XR_TYPE_INSTANCE_CREATE_INFO);
+            createInfo.next(androidCreateInfo.address());
+            createInfo.createFlags(0);
+            createInfo.applicationInfo(applicationInfo);
+            createInfo.enabledApiLayerNames(null);
+            createInfo.enabledExtensionNames(extensions.flip());
+
+            //Create XR instance
+            PointerBuffer instancePtr = stack.callocPointer(1);
+            int xrResult = XR10.xrCreateInstance(createInfo, instancePtr);
+            if (xrResult == XR10.XR_ERROR_RUNTIME_FAILURE) {
+                throw new RuntimeException("Failed to create xrInstance, are you sure your headset is plugged in?");
+            } else if (xrResult == XR10.XR_ERROR_INSTANCE_LOST) {
+                throw new RuntimeException("Failed to create xrInstance due to runtime updating");
+            } else if (xrResult < 0) {
+                throw new RuntimeException("XR method returned " + xrResult);
+            }
+            instance = new XrInstance(instancePtr.get(0), createInfo);
+
+            this.poseMatrices = new Matrix4f[64];
+
+            for (int i = 0; i < this.poseMatrices.length; ++i) {
+                this.poseMatrices[i] = new Matrix4f();
+            }
+
+            this.initSuccess = true;
+        }
+    }
+
+    public static MCOpenXR get() {
+        return ome;
+    }
+
+    private void initializeOpenXRSession() {
+        try (MemoryStack stack = MemoryStack.stackPush()) {
+            //Create system
+            XrSystemGetInfo system = XrSystemGetInfo.calloc(stack);
+            system.type(XR10.XR_TYPE_SYSTEM_GET_INFO);
+            system.next(NULL);
+            system.formFactor(XR10.XR_FORM_FACTOR_HEAD_MOUNTED_DISPLAY);
+
+            LongBuffer longBuffer = stack.callocLong(1);
+            int error = XR10.xrGetSystem(instance, system, longBuffer);
+            logError(error, "xrGetSystem",  "");
+            this.systemID = longBuffer.get(0);
+
+            if (systemID == 0) {
+                throw new RuntimeException("No compatible headset detected");
+            }
+
+            //Bind graphics
+            Struct graphics = this.getGraphicsAPI(stack);
+
+            //Create session
+            XrSessionCreateInfo info = XrSessionCreateInfo.calloc(stack);
+            info.type(XR10.XR_TYPE_SESSION_CREATE_INFO);
+            info.next(graphics.address());
+            info.createFlags(0);
+            info.systemId(systemID);
+
+            PointerBuffer sessionPtr = stack.callocPointer(1);
+            error = XR10.xrCreateSession(instance, info, sessionPtr);
+            logError(error, "xrCreateSession",  "");
+
+            session = new XrSession(sessionPtr.get(0), instance);
+
+            XrSessionBeginInfo sessionBeginInfo = XrSessionBeginInfo.calloc(stack);
+            sessionBeginInfo.type(XR10.XR_TYPE_SESSION_BEGIN_INFO);
+            sessionBeginInfo.next(NULL);
+            sessionBeginInfo.primaryViewConfigurationType(XR10.XR_VIEW_CONFIGURATION_TYPE_PRIMARY_STEREO);
+
+            error = XR10.xrBeginSession(session, sessionBeginInfo);
+            logError(error, "xrBeginSession",  "");
+            this.isActive = true;
+
+        }
+    }
+
+    private void initializeOpenXRSpace() {
+        try (MemoryStack stack = MemoryStack.stackPush()){
+            XrPosef identityPose = XrPosef.calloc(stack);
+            identityPose.set(
+                XrQuaternionf.calloc(stack).set(0, 0, 0, 1),
+                XrVector3f.calloc(stack)
+            );
+
+            XrReferenceSpaceCreateInfo referenceSpaceCreateInfo = XrReferenceSpaceCreateInfo.calloc(stack);
+            referenceSpaceCreateInfo.type(XR10.XR_TYPE_REFERENCE_SPACE_CREATE_INFO);
+            referenceSpaceCreateInfo.next(NULL);
+            referenceSpaceCreateInfo.referenceSpaceType(XR10.XR_REFERENCE_SPACE_TYPE_STAGE);
+            referenceSpaceCreateInfo.poseInReferenceSpace(identityPose);
+
+            PointerBuffer pp = stack.callocPointer(1);
+            int error = XR10.xrCreateReferenceSpace(session, referenceSpaceCreateInfo, pp);
+            xrAppSpace = new XrSpace(pp.get(0), session);
+            logError(error, "xrCreateReferenceSpace",  "XR_REFERENCE_SPACE_TYPE_STAGE");
+
+            referenceSpaceCreateInfo.referenceSpaceType(XR10.XR_REFERENCE_SPACE_TYPE_VIEW);
+            error = XR10.xrCreateReferenceSpace(session, referenceSpaceCreateInfo, pp);
+            logError(error, "xrCreateReferenceSpace",  "XR_REFERENCE_SPACE_TYPE_VIEW");
+            xrViewSpace = new XrSpace(pp.get(0), session);
+        }
+    }
+
+    private void initializeOpenXRSwapChain() {
+        try (MemoryStack stack = stackPush()) {
+            //Check amount of views
+            IntBuffer intBuf = stack.callocInt(1);
+            int error = XR10.xrEnumerateViewConfigurationViews(instance, systemID,  XR10.XR_VIEW_CONFIGURATION_TYPE_PRIMARY_STEREO, intBuf, null);
+            logError(error, "xrEnumerateViewConfigurationViews",  "get count");
+
+            //Get all views
+            ByteBuffer viewConfBuffer = bufferStack(intBuf.get(0), XrViewConfigurationView.SIZEOF, XR10.XR_TYPE_VIEW_CONFIGURATION_VIEW);
+            XrViewConfigurationView.Buffer views = new XrViewConfigurationView.Buffer(viewConfBuffer);
+            error = XR10.xrEnumerateViewConfigurationViews(instance, systemID,  XR10.XR_VIEW_CONFIGURATION_TYPE_PRIMARY_STEREO, intBuf, views);
+            logError(error, "xrEnumerateViewConfigurationViews",  "get views");
+            int viewCountNumber = intBuf.get(0);
+
+            this.viewBuffer = new XrView.Buffer(
+                bufferHeap(viewCountNumber, XrView.SIZEOF, XR10.XR_TYPE_VIEW)
+            );
+            //Check swapchain formats
+            error = XR10.xrEnumerateSwapchainFormats(session, intBuf, null);
+            logError(error, "xrEnumerateSwapchainFormats",  "get count");
+
+            //Get swapchain formats
+            LongBuffer swapchainFormats = stack.callocLong(intBuf.get(0));
+            error = XR10.xrEnumerateSwapchainFormats(session, intBuf, swapchainFormats);
+            logError(error, "xrEnumerateSwapchainFormats",  "get formats");
+
+            long[] desiredSwapchainFormats = {
+                //SRGB formats
+                GL21.GL_SRGB8_ALPHA8,
+                GL21.GL_SRGB8,
+                //others
+                GL11.GL_RGB10_A2,
+                GL30.GL_RGBA16F,
+                GL30.GL_RGB16F,
+
+                // The two below should only be used as a fallback, as they are linear color formats without enough bits for color
+                // depth, thus leading to banding.
+                GL11.GL_RGBA8,
+                GL31.GL_RGBA8_SNORM,
+            };
+
+            //Choose format
+            long chosenFormat = 0;
+            for (long glFormatIter : desiredSwapchainFormats) {
+                swapchainFormats.rewind();
+                while (swapchainFormats.hasRemaining()) {
+                    if (glFormatIter == swapchainFormats.get()) {
+                        chosenFormat = glFormatIter;
+                        break;
+                    }
+                }
+                if (chosenFormat != 0) {
+                    break;
+                }
+            }
+
+            if (chosenFormat == 0) {
+                var formats = new ArrayList<Long>();
+                swapchainFormats.rewind();
+                while (swapchainFormats.hasRemaining()) {
+                    formats.add(swapchainFormats.get());
+                }
+                throw new RuntimeException("No compatible swapchain / framebuffer format available: " + formats);
+            }
+
+            //Make swapchain
+            XrViewConfigurationView viewConfig = views.get(0);
+            XrSwapchainCreateInfo swapchainCreateInfo = XrSwapchainCreateInfo.calloc(stack);
+            swapchainCreateInfo.type(XR10.XR_TYPE_SWAPCHAIN_CREATE_INFO);
+            swapchainCreateInfo.next(NULL);
+            swapchainCreateInfo.createFlags(0);
+            swapchainCreateInfo.usageFlags(XR10.XR_SWAPCHAIN_USAGE_COLOR_ATTACHMENT_BIT);
+            swapchainCreateInfo.format(chosenFormat);
+            swapchainCreateInfo.sampleCount(1);
+            swapchainCreateInfo.width(viewConfig.recommendedImageRectWidth());
+            swapchainCreateInfo.height(viewConfig.recommendedImageRectHeight());
+            swapchainCreateInfo.faceCount(1);
+            swapchainCreateInfo.arraySize(2);
+            swapchainCreateInfo.mipCount(1);
+
+            PointerBuffer handlePointer = stack.callocPointer(1);
+            error = XR10.xrCreateSwapchain(session, swapchainCreateInfo, handlePointer);
+            logError(error, "xrCreateSwapchain",  "format: " + chosenFormat);
+            swapchain = new XrSwapchain(handlePointer.get(0), session);
+            this.width = swapchainCreateInfo.width();
+            this.height = swapchainCreateInfo.height();
+        }
+    }
+
+    private Struct getGraphicsAPI(MemoryStack stack) {
+        XrGraphicsRequirementsOpenGLESKHR graphicsRequirements = XrGraphicsRequirementsOpenGLESKHR.calloc(stack).type(KHROpenGLESEnable.XR_TYPE_GRAPHICS_REQUIREMENTS_OPENGL_ES_KHR);
+        KHROpenGLESEnable.xrGetOpenGLESGraphicsRequirementsKHR(instance, systemID, graphicsRequirements);
+
+        XrSystemProperties systemProperties = XrSystemProperties.calloc(stack).type(XR10.XR_TYPE_SYSTEM_PROPERTIES);
+        int error = XR10.xrGetSystemProperties(instance, systemID, systemProperties);
+        logError(error, "xrGetSystemProperties",  "");
+        XrSystemTrackingProperties trackingProperties = systemProperties.trackingProperties();
+        XrSystemGraphicsProperties graphicsProperties = systemProperties.graphicsProperties();
+
+        this.systemName = memUTF8(memAddress(systemProperties.systemName()));
+        int vendor = systemProperties.vendorId();
+        boolean orientationTracking = trackingProperties.orientationTracking();
+        boolean positionTracking = trackingProperties.positionTracking();
+        int maxWidth = graphicsProperties.maxSwapchainImageWidth();
+        int maxHeight = graphicsProperties.maxSwapchainImageHeight();
+        int maxLayerCount = graphicsProperties.maxLayerCount();
+
+        VRSettings.logger.info("Found device with id:  {}", systemID);
+        VRSettings.logger.info("Headset Name: {}, Vendor: {}", systemName, vendor);
+        VRSettings.logger.info("Headset Orientation Tracking: {}, Position Tracking: {}", orientationTracking, positionTracking);
+        VRSettings.logger.info("Headset Max Width: {}, Max Height: {}, Max Layer Count: {}", maxWidth, maxHeight, maxLayerCount);
+
+        //Bind the OpenGLES context to the OpenXR instance and create the session
+        return XrGraphicsBindingOpenGLESAndroidKHR.callocStack(stack).set(
+            KHROpenGLESEnable.XR_TYPE_GRAPHICS_BINDING_OPENGL_ES_ANDROID_KHR,
+            0,
+            VLoader.getEGLDisp(),
+            VLoader.getEGLCfg(),
+            VLoader.getEGLCtx()
+        );
+    }
+
+    /**
+     * Creates an array of XrStructs with their types pre set to @param type
+     */
+    static ByteBuffer bufferStack(int capacity, int sizeof, int type) {
+        ByteBuffer b = stackCalloc(capacity * sizeof);
+
+        for (int i = 0; i < capacity; i++) {
+            b.position(i * sizeof);
+            b.putInt(type);
+        }
+        b.rewind();
+        return b;
+    }
+
+
+    @Override
+    public boolean postinit() throws RenderConfigException {
+        this.initInputAndApplication();
+        return inputInitialized;
+    }
+
+    private void initInputAndApplication() {
+        this.populateInputActions();
+
+        //this.generateActionManifest();
+        //this.loadActionManifest();
+        this.loadActionHandles();
+        this.loadDefaultBindings();
+        //this.installApplicationManifest(false);
+        this.inputInitialized = true;
+
+    }
+
+    @Override
+    public Matrix4f getControllerComponentTransform(int var1, String var2) {
+        return Utils.Matrix4fSetIdentity(new Matrix4f());
+    }
+
+    @Override
+    public boolean hasThirdController() {
+        return false;
+    }
+
+    @Override
+    public List<Long> getOrigins(VRInputAction var1) {
+        try (MemoryStack stack = MemoryStack.stackPush()){
+            XrBoundSourcesForActionEnumerateInfo info = XrBoundSourcesForActionEnumerateInfo.calloc(stack);
+            info.type(XR10.XR_TYPE_BOUND_SOURCES_FOR_ACTION_ENUMERATE_INFO);
+            info.next(NULL);
+            info.action(new XrAction(var1.handle, new XrActionSet(actionSetHandles.get(var1.actionSet), instance)));
+            IntBuffer buf = stack.callocInt(1);
+            int error = XR10.xrEnumerateBoundSourcesForAction(session, info, buf, null);
+            logError(error, "xrEnumerateBoundSourcesForAction",  var1.name);
+
+            int size = buf.get();
+            if (size <= 0) {
+                return List.of(0L);
+            }
+
+            buf = stack.callocInt(size);
+            LongBuffer longbuf = stack.callocLong(size);
+            error = XR10.xrEnumerateBoundSourcesForAction(session, info, buf, longbuf);
+            logError(error, "xrEnumerateBoundSourcesForAction",  var1.name);
+            long[] array;
+            if (longbuf.hasArray()) { //TODO really?
+                array = longbuf.array();
+            } else {
+                longbuf.rewind();
+                array = new long[longbuf.remaining()];
+                int index = 0;
+                while (longbuf.hasRemaining()) {
+                    array[index++] = longbuf.get();
+                }
+            }
+            return Arrays.stream(array).boxed().toList();
+        }
+    }
+
+    @Override
+    public String getOriginName(long l) {
+        try (MemoryStack stack = MemoryStack.stackPush()){
+            XrInputSourceLocalizedNameGetInfo info = XrInputSourceLocalizedNameGetInfo.calloc(stack);
+            info.type(XR10.XR_TYPE_INPUT_SOURCE_LOCALIZED_NAME_GET_INFO);
+            info.next(0);
+            info.sourcePath(l);
+            info.whichComponents(XR10.XR_INPUT_SOURCE_LOCALIZED_NAME_COMPONENT_BIT);
+
+            IntBuffer buf = stack.callocInt(1);
+            int error = XR10.xrGetInputSourceLocalizedName(session, info, buf, null);
+            logError(error, "xrGetInputSourceLocalizedName",  "get length");
+
+            int size = buf.get();
+            if (size <= 0) {
+                return "";
+            }
+
+            buf = stack.callocInt(size);
+            ByteBuffer byteBuffer = stack.calloc(size);
+            error = XR10.xrGetInputSourceLocalizedName(session, info, buf, byteBuffer);
+            logError(error, "xrGetInputSourceLocalizedName",  "get String");
+            return new String(byteBuffer.array());
+        }
+    }
+
+    @Override
+    public VRRenderer createVRRenderer() {
+        return new OpenXRStereoRenderer(this);
+    }
+
+    @Override
+    public boolean isActive() {
+        this.pollVREvents();
+        return isActive;
+    }
+
+    @Override
+    public ControllerType getOriginControllerType(long i) {
+        if (i == aim[0]) {
+            return ControllerType.RIGHT;
+        }
+        return ControllerType.LEFT;
+    }
+
+    //TODO Collect and register all actions
+    private void loadActionHandles() {
+        for (VRInputActionSet vrinputactionset : VRInputActionSet.values()) {
+            long actionSet = makeActionSet(instance, vrinputactionset.name, vrinputactionset.localizedName, 0);
+            this.actionSetHandles.put(vrinputactionset, actionSet);
+        }
+
+        for (VRInputAction vrinputaction : this.inputActions.values()) {
+            long action = createAction(vrinputaction.name, vrinputaction.name, vrinputaction.type, new XrActionSet(this.actionSetHandles.get(vrinputaction.actionSet), instance));
+            vrinputaction.setHandle(action);
+        }
+
+        setupControllers();
+
+        XrActionSet actionSet = new XrActionSet(this.actionSetHandles.get(VRInputActionSet.GLOBAL), instance);
+        this.haptics[0] = createAction("/actions/global/out/righthaptic", "/actions/global/out/righthaptic", "haptic", actionSet);
+        this.haptics[1] = createAction("/actions/global/out/lefthaptic", "/actions/global/out/lefthaptic", "haptic", actionSet);
+
+    }
+
+    private void setupControllers() {
+        XrActionSet actionSet = new XrActionSet(this.actionSetHandles.get(VRInputActionSet.GLOBAL), instance);
+        this.grip[0] = createAction("/actions/global/in/righthand", "/actions/global/in/righthand", "pose", actionSet);
+        this.grip[1] = createAction("/actions/global/in/lefthand", "/actions/global/in/lefthand", "pose", actionSet);
+        this.aim[0] = createAction("/actions/global/in/righthandaim", "/actions/global/in/righthandaim", "pose", actionSet);
+        this.aim[1] = createAction("/actions/global/in/lefthandaim", "/actions/global/in/lefthandaim", "pose", actionSet);
+    }
+
+    private void loadDefaultBindings() {
+        try (MemoryStack stack = MemoryStack.stackPush()) {
+            int error;
+            for (String headset: XRBindings.supportedHeadsets()) {
+                VRSettings.logger.info("loading defaults for {}", headset);
+                Pair<String, String>[] defaultBindings = XRBindings.getBinding(headset).toArray(new Pair[0]);
+                XrActionSuggestedBinding.Buffer bindings = XrActionSuggestedBinding.calloc(defaultBindings.length + 6, stack); //TODO different way of adding controller poses
+
+                for (int i = 0; i < defaultBindings.length; i++) {
+                    Pair<String, String> pair = defaultBindings[i];
+                    VRInputAction binding = this.getInputActionByName(pair.getLeft());
+                    if (binding.handle == 0L) {
+                        VRSettings.logger.error("Handle for '{}'/'{}' is null", pair.getLeft(), pair.getRight());
+                        continue;
+                    }
+                    bindings.get(i).set(
+                        new XrAction(binding.handle, new XrActionSet(actionSetHandles.get(binding.actionSet), instance)),
+                        getPath(pair.getRight())
+                    );
+                }
+
+                //TODO make this also changeable?
+                XrActionSet actionSet = new XrActionSet(actionSetHandles.get(VRInputActionSet.GLOBAL), instance);
+                bindings.get(defaultBindings.length).set(
+                    new XrAction(this.grip[0], actionSet),
+                    getPath("/user/hand/right/input/grip/pose")
+                );
+                bindings.get(defaultBindings.length + 1).set(
+                    new XrAction(this.grip[1], actionSet),
+                    getPath("/user/hand/left/input/grip/pose")
+                );
+                bindings.get(defaultBindings.length + 2).set(
+                    new XrAction(this.aim[0], actionSet),
+                    getPath("/user/hand/right/input/aim/pose")
+                );
+                bindings.get(defaultBindings.length + 3).set(
+                    new XrAction(this.aim[1], actionSet),
+                    getPath("/user/hand/left/input/aim/pose")
+                );
+
+                bindings.get(defaultBindings.length + 4).set(
+                    new XrAction(this.haptics[0], actionSet),
+                    getPath("/user/hand/right/output/haptic")
+                );
+
+                bindings.get(defaultBindings.length + 5).set(
+                    new XrAction(this.haptics[1], actionSet),
+                    getPath("/user/hand/left/output/haptic")
+                );
+
+                XrInteractionProfileSuggestedBinding suggested_binds = XrInteractionProfileSuggestedBinding.calloc(stack);
+                suggested_binds.type(XR10.XR_TYPE_INTERACTION_PROFILE_SUGGESTED_BINDING);
+                suggested_binds.next(NULL);
+                suggested_binds.interactionProfile(getPath(headset));
+                suggested_binds.suggestedBindings(bindings);
+
+                error = XR10.xrSuggestInteractionProfileBindings(instance, suggested_binds);
+                logError(error, "xrSuggestInteractionProfileBindings",  headset);
+            }
+
+
+            XrSessionActionSetsAttachInfo attach_info = XrSessionActionSetsAttachInfo.calloc(stack);
+            attach_info.type(XR10.XR_TYPE_SESSION_ACTION_SETS_ATTACH_INFO);
+            attach_info.next(NULL);
+            attach_info.actionSets(stackPointers(actionSetHandles.values().stream().mapToLong(value -> value).toArray()));
+
+            error = XR10.xrAttachSessionActionSets(session, attach_info);
+            logError(error, "xrAttachSessionActionSets",  "");
+
+            XrActionSet actionSet = new XrActionSet(this.actionSetHandles.get(VRInputActionSet.GLOBAL), instance);
+            XrActionSpaceCreateInfo grip_left = XrActionSpaceCreateInfo.calloc(stack);
+            grip_left.type(XR10.XR_TYPE_ACTION_SPACE_CREATE_INFO);
+            grip_left.next(NULL);
+            grip_left.action(new XrAction(grip[0], actionSet));
+            grip_left.subactionPath(getPath("/user/hand/right"));
+            grip_left.poseInActionSpace(POSE_IDENTITY);
+            PointerBuffer pp = stackCallocPointer(1);
+            error = XR10.xrCreateActionSpace(session, grip_left, pp);
+            logError(error, "xrCreateActionSpace",  "grip: /user/hand/right");
+            this.gripSpace[0] = new XrSpace(pp.get(0), session);
+
+            grip_left.action(new XrAction(grip[1], actionSet));
+            grip_left.subactionPath(getPath("/user/hand/left"));
+            error = XR10.xrCreateActionSpace(session, grip_left, pp);
+            logError(error, "xrCreateActionSpace",  "grip: /user/hand/left");
+            this.gripSpace[1] = new XrSpace(pp.get(0), session);
+
+            grip_left.action(new XrAction(aim[0], actionSet));
+            grip_left.subactionPath(getPath("/user/hand/right"));
+            error = XR10.xrCreateActionSpace(session, grip_left, pp);
+            logError(error, "xrCreateActionSpace",  "aim: /user/hand/right");
+            this.aimSpace[0] = new XrSpace(pp.get(0), session);
+
+            grip_left.action(new XrAction(aim[1], actionSet));
+            grip_left.subactionPath(getPath("/user/hand/left"));
+            error = XR10.xrCreateActionSpace(session, grip_left, pp);
+            logError(error, "xrCreateActionSpace",  "aim: /user/hand/left");
+            this.aimSpace[1] = new XrSpace(pp.get(0), session);
+
+        }
+    }
+
+    public long getPath(String pathString) {
+        return this.paths.computeIfAbsent(pathString, s -> {
+            try (MemoryStack ignored = stackPush()) {
+                LongBuffer buf = stackCallocLong(1);
+                int error = XR10.xrStringToPath(instance, pathString, buf);
+                logError(error, "getPath",  pathString);
+                return buf.get();
+            }
+        });
+    }
+
+    private long createAction(String name, String localisedName, String type, XrActionSet actionSet) {
+        try (MemoryStack stack = MemoryStack.stackPush()){
+            String s = name.split("/")[name.split("/").length -1].toLowerCase();
+            XrActionCreateInfo hands = XrActionCreateInfo.calloc(stack);
+            hands.type(XR10.XR_TYPE_ACTION_CREATE_INFO);
+            hands.next(NULL);
+            hands.actionName(memUTF8(s));
+            switch (type) {
+                case "boolean" -> hands.actionType(XR10.XR_ACTION_TYPE_BOOLEAN_INPUT);
+                case "vector1" -> hands.actionType(XR10.XR_ACTION_TYPE_FLOAT_INPUT);
+                case "vector2" -> hands.actionType(XR10.XR_ACTION_TYPE_VECTOR2F_INPUT);
+                case "pose" -> hands.actionType(XR10.XR_ACTION_TYPE_POSE_INPUT);
+                case "haptic" -> hands.actionType(XR10.XR_ACTION_TYPE_VIBRATION_OUTPUT);
+            }
+            hands.countSubactionPaths(0);
+            hands.subactionPaths(null);
+            hands.localizedActionName(memUTF8(s));
+            PointerBuffer buffer = stackCallocPointer(1);
+
+            int error = XR10.xrCreateAction(actionSet, hands, buffer);
+            logError(error, "xrCreateAction",  "name:", name, "type:", type);
+            return buffer.get(0);
+        }
+    }
+
+    private long makeActionSet(XrInstance instance, String name, String localisedName, int priority) {
+        try (MemoryStack stack = MemoryStack.stackPush()){
+            XrActionSetCreateInfo info = XrActionSetCreateInfo.calloc(stack);
+            info.type(XR10.XR_TYPE_ACTION_SET_CREATE_INFO);
+            info.next(NULL);
+            info.actionSetName(memUTF8(localisedName.toLowerCase()));
+            info.localizedActionSetName(memUTF8(localisedName.toLowerCase()));
+            info.priority(priority);
+            PointerBuffer buffer = stack.callocPointer(1);
+
+            int error = XR10.xrCreateActionSet(instance, info, buffer);
+            logError(error, "makeActionSet", localisedName.toLowerCase());
+            return buffer.get(0);
+        }
+    }
+
+    static ByteBuffer bufferHeap(int capacity, int sizeof, int type) {
+        ByteBuffer b = memCalloc(capacity * sizeof);
+
+        for (int i = 0; i < capacity; i++) {
+            b.position(i * sizeof);
+            b.putInt(type);
+        }
+        b.rewind();
+        return b;
+    }
+
+    /**
+     * gets the String for the given xrResult
+     */
+    private String getResultName(int xrResult) {
+        String resultString = switch (xrResult) {
+            case 1 -> "XR_TIMEOUT_EXPIRED";
+            case 3 -> "XR_SESSION_LOSS_PENDING";
+            case 4 -> "XR_EVENT_UNAVAILABLE";
+            case 7 -> "XR_SPACE_BOUNDS_UNAVAILABLE";
+            case 8 -> "XR_SESSION_NOT_FOCUSED";
+            case 9 -> "XR_FRAME_DISCARDED";
+            case -1 -> "XR_ERROR_VALIDATION_FAILURE";
+            case -2 -> "XR_ERROR_RUNTIME_FAILURE";
+            case -3 -> "XR_ERROR_OUT_OF_MEMORY";
+            case -4 -> "XR_ERROR_API_VERSION_UNSUPPORTED";
+            case -6 -> "XR_ERROR_INITIALIZATION_FAILED";
+            case -7 -> "XR_ERROR_FUNCTION_UNSUPPORTED";
+            case -8 -> "XR_ERROR_FEATURE_UNSUPPORTED";
+            case -9 -> "XR_ERROR_EXTENSION_NOT_PRESENT";
+            case -10 -> "XR_ERROR_LIMIT_REACHED";
+            case -11 -> "XR_ERROR_SIZE_INSUFFICIENT";
+            case -12 -> "XR_ERROR_HANDLE_INVALID";
+            case -13 -> "XR_ERROR_INSTANCE_LOST";
+            case -14 -> "XR_ERROR_SESSION_RUNNING";
+            case -16 -> "XR_ERROR_SESSION_NOT_RUNNING";
+            case -17 -> "XR_ERROR_SESSION_LOST";
+            case -18 -> "XR_ERROR_SYSTEM_INVALID";
+            case -19 -> "XR_ERROR_PATH_INVALID";
+            case -20 -> "XR_ERROR_PATH_COUNT_EXCEEDED";
+            case -21 -> "XR_ERROR_PATH_FORMAT_INVALID";
+            case -22 -> "XR_ERROR_PATH_UNSUPPORTED";
+            case -23 -> "XR_ERROR_LAYER_INVALID";
+            case -24 -> "XR_ERROR_LAYER_LIMIT_EXCEEDED";
+            case -25 -> "XR_ERROR_SWAPCHAIN_RECT_INVALID";
+            case -26 -> "XR_ERROR_SWAPCHAIN_FORMAT_UNSUPPORTED";
+            case -27 -> "XR_ERROR_ACTION_TYPE_MISMATCH";
+            case -28 -> "XR_ERROR_SESSION_NOT_READY";
+            case -29 -> "XR_ERROR_SESSION_NOT_STOPPING";
+            case -30 -> "XR_ERROR_TIME_INVALID";
+            case -31 -> "XR_ERROR_REFERENCE_SPACE_UNSUPPORTED";
+            case -32 -> "XR_ERROR_FILE_ACCESS_ERROR";
+            case -33 -> "XR_ERROR_FILE_CONTENTS_INVALID";
+            case -34 -> "XR_ERROR_FORM_FACTOR_UNSUPPORTED";
+            case -35 -> "XR_ERROR_FORM_FACTOR_UNAVAILABLE";
+            case -36 -> "XR_ERROR_API_LAYER_NOT_PRESENT";
+            case -37 -> "XR_ERROR_CALL_ORDER_INVALID";
+            case -38 -> "XR_ERROR_GRAPHICS_DEVICE_INVALID";
+            case -39 -> "XR_ERROR_POSE_INVALID";
+            case -40 -> "XR_ERROR_INDEX_OUT_OF_RANGE";
+            case -41 -> "XR_ERROR_VIEW_CONFIGURATION_TYPE_UNSUPPORTED";
+            case -42 -> "XR_ERROR_ENVIRONMENT_BLEND_MODE_UNSUPPORTED";
+            case -44 -> "XR_ERROR_NAME_DUPLICATED";
+            case -45 -> "XR_ERROR_NAME_INVALID";
+            case -46 -> "XR_ERROR_ACTIONSET_NOT_ATTACHED";
+            case -47 -> "XR_ERROR_ACTIONSETS_ALREADY_ATTACHED";
+            case -48 -> "XR_ERROR_LOCALIZED_NAME_DUPLICATED";
+            case -49 -> "XR_ERROR_LOCALIZED_NAME_INVALID";
+            case -50 -> "XR_ERROR_GRAPHICS_REQUIREMENTS_CALL_MISSING";
+            case -51 -> "XR_ERROR_RUNTIME_UNAVAILABLE";
+            default -> null;
+        };
+        if (resultString == null) {
+            // ask the runtime for the xrResult name
+            try (MemoryStack stack = MemoryStack.stackPush()) {
+                ByteBuffer str = stack.calloc(XR10.XR_MAX_RESULT_STRING_SIZE);
+
+                if (XR10.xrResultToString(instance, xrResult, str) == XR10.XR_SUCCESS) {
+                    resultString = (memUTF8(memAddress(str)));
+                } else {
+                    resultString = "Unknown Error: " + xrResult;
+                }
+            }
+        }
+        return resultString;
+    }
+
+    /**
+     * logs only errors
+     * @param xrResult result to check
+     * @param caller where the xrResult came from
+     * @param args arguments may be helpful in locating the error
+     */
+    protected void logError(int xrResult, String caller, String... args) {
+        if (xrResult < 0) {
+            VRSettings.logger.error("{} for {} errored: {}", caller, String.join(" ", args), getResultName(xrResult));
+        }
+    }
+
+    /**
+     * logs all results except XR_SUCCESS
+     * @param xrResult result to check
+     * @param caller where the xrResult came from
+     * @param args arguments may be helpful in locating the error
+     */
+    protected void logAll(int xrResult, String caller, String... args) {
+        if (xrResult != XR10.XR_SUCCESS) {
+            VRSettings.logger.error("{} for {} errored: {}", caller, String.join(" ", args), getResultName(xrResult));
+        }
+    }
+}
Index: common/src/main/java/org/vivecraft/client_vr/provider/openxr/OpenXRHapticSchedular.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/src/main/java/org/vivecraft/client_vr/provider/openxr/OpenXRHapticSchedular.java b/common/src/main/java/org/vivecraft/client_vr/provider/openxr/OpenXRHapticSchedular.java
new file mode 100644
--- /dev/null	(revision a1131575d6931b12d3cb0b9f8a519b861bc5ca4c)
+++ b/common/src/main/java/org/vivecraft/client_vr/provider/openxr/OpenXRHapticSchedular.java	(revision a1131575d6931b12d3cb0b9f8a519b861bc5ca4c)
@@ -0,0 +1,47 @@
+package org.vivecraft.client_vr.provider.openxr;
+
+import org.lwjgl.openxr.*;
+import org.lwjgl.system.MemoryStack;
+import org.vivecraft.client_vr.ClientDataHolderVR;
+import org.vivecraft.client_vr.provider.ControllerType;
+import org.vivecraft.client_vr.provider.HapticScheduler;
+import org.vivecraft.client_vr.provider.control.VRInputActionSet;
+
+import java.util.concurrent.TimeUnit;
+
+import static java.sql.Types.NULL;
+
+public class OpenXRHapticSchedular extends HapticScheduler {
+
+    private void triggerHapticPulse(ControllerType controller, float durationSeconds, float frequency, float amplitude) {
+        try (MemoryStack stack = MemoryStack.stackPush()){
+            int i = controller == ControllerType.RIGHT ? 0 : 1;
+            if (ClientDataHolderVR.getInstance().vrSettings.reverseHands) {
+                i = controller == ControllerType.RIGHT ? 1 : 0;
+            }
+            XrActionSet actionSet = new XrActionSet(MCOpenXR.get().getActionSetHandle(VRInputActionSet.GLOBAL), MCOpenXR.get().instance);
+            XrHapticActionInfo info = XrHapticActionInfo.calloc(stack);
+            info.type(XR10.XR_TYPE_HAPTIC_ACTION_INFO);
+            info.next(NULL);
+            info.action(new XrAction(MCOpenXR.get().haptics[i], actionSet));
+
+            XrHapticVibration vibration = XrHapticVibration.calloc(stack);
+            vibration.type(XR10.XR_ACTION_TYPE_VIBRATION_OUTPUT);
+            vibration.next(NULL);
+            vibration.duration((long) (durationSeconds * 1_000_000_000));
+            vibration.frequency(frequency);
+            vibration.amplitude(amplitude);
+
+            int error = XR10.xrApplyHapticFeedback(MCOpenXR.get().session, info, XrHapticBaseHeader.create(vibration));
+            MCOpenXR.get().logError(error, "xrApplyHapticFeedback", "");
+        }
+    }
+
+    @Override
+    public void queueHapticPulse(ControllerType controller, float durationSeconds, float frequency, float amplitude, float delaySeconds) {
+        this.executor.schedule(() ->
+        {
+            this.triggerHapticPulse(controller, durationSeconds, frequency, amplitude);
+        }, (long) (delaySeconds * 1000000.0F), TimeUnit.MICROSECONDS);
+    }
+}
Index: common/src/main/java/org/vivecraft/client_vr/provider/openxr/OpenXRStereoRenderer.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/src/main/java/org/vivecraft/client_vr/provider/openxr/OpenXRStereoRenderer.java b/common/src/main/java/org/vivecraft/client_vr/provider/openxr/OpenXRStereoRenderer.java
new file mode 100644
--- /dev/null	(revision a1131575d6931b12d3cb0b9f8a519b861bc5ca4c)
+++ b/common/src/main/java/org/vivecraft/client_vr/provider/openxr/OpenXRStereoRenderer.java	(revision a1131575d6931b12d3cb0b9f8a519b861bc5ca4c)
@@ -0,0 +1,182 @@
+package org.vivecraft.client_vr.provider.openxr;
+
+import com.mojang.blaze3d.pipeline.RenderTarget;
+import net.minecraft.util.Tuple;
+import org.joml.Matrix4f;
+import org.lwjgl.PointerBuffer;
+import org.lwjgl.opengl.GL31;
+import org.lwjgl.openxr.*;
+import org.lwjgl.system.MemoryStack;
+import org.vivecraft.client_vr.ClientDataHolderVR;
+import org.vivecraft.client_vr.VRTextureTarget;
+import org.vivecraft.client_vr.provider.VRRenderer;
+import org.vivecraft.client_vr.render.RenderConfigException;
+
+import java.nio.ByteBuffer;
+import java.nio.IntBuffer;
+
+import static org.lwjgl.system.MemoryUtil.memAddress;
+import static org.lwjgl.system.MemoryUtil.memUTF8;
+
+public class OpenXRStereoRenderer extends VRRenderer {
+    private final MCOpenXR openxr;
+    private int swapIndex;
+    private VRTextureTarget[] leftFramebuffers;
+    private VRTextureTarget[] rightFramebuffers;
+    private boolean render;
+    private XrCompositionLayerProjectionView.Buffer projectionLayerViews;
+    private VRTextureTarget rightFramebuffer;
+    private VRTextureTarget leftFramebuffer;
+
+
+    public OpenXRStereoRenderer(MCOpenXR vr) {
+        super(vr);
+        this.openxr = vr;
+    }
+
+    @Override
+    public void createRenderTexture(int width, int height) throws RenderConfigException{
+        try (MemoryStack stack = MemoryStack.stackPush()) {
+
+            //Get amount of views in the swapchain
+            IntBuffer intBuffer = stack.ints(0); //Set value to 0
+            int error = XR10.xrEnumerateSwapchainImages(openxr.swapchain, intBuffer, null);
+            this.openxr.logError(error, "xrEnumerateSwapchainImages", "get count");
+
+            //Now we know the amount, create the image buffer
+            int imageCount = intBuffer.get(0);
+            XrSwapchainImageOpenGLKHR.Buffer swapchainImageBuffer = XrSwapchainImageOpenGLKHR.calloc(imageCount, stack);
+            for (XrSwapchainImageOpenGLKHR image : swapchainImageBuffer) {
+                image.type(KHROpenGLEnable.XR_TYPE_SWAPCHAIN_IMAGE_OPENGL_KHR);
+            }
+
+            error = XR10.xrEnumerateSwapchainImages(openxr.swapchain, intBuffer, XrSwapchainImageBaseHeader.create(swapchainImageBuffer.address(), swapchainImageBuffer.capacity()));
+            this.openxr.logError(error, "xrEnumerateSwapchainImages", "get images");
+
+            this.leftFramebuffers = new VRTextureTarget[imageCount];
+            this.rightFramebuffers = new VRTextureTarget[imageCount];
+
+            for (int i = 0; i < imageCount; i++) {
+                XrSwapchainImageOpenGLKHR openxrImage = swapchainImageBuffer.get(i);
+                leftFramebuffers[i] = new VRTextureTarget("L Eye " + i, width, height, openxrImage.image(), 0);
+                this.checkGLError("Left Eye framebuffer setup");
+                rightFramebuffers[i] = new VRTextureTarget("R Eye " + i, width, height, openxrImage.image(), 1);
+                this.checkGLError("Right Eye framebuffer setup");
+            }
+
+            this.rightFramebuffer = new VRTextureTarget("R Eye mirror", width, height, true, false, -1, true, true, ClientDataHolderVR.getInstance().vrSettings.vrUseStencil);
+            this.leftFramebuffer = new VRTextureTarget("L Eye mirror", width, height, true, false, -1, true, true, ClientDataHolderVR.getInstance().vrSettings.vrUseStencil);
+        }
+    }
+
+    @Override
+    public void setupRenderConfiguration(boolean render) throws Exception {
+        super.setupRenderConfiguration(render);
+        
+        if (!render) {
+            return;
+        }
+        this.projectionLayerViews = XrCompositionLayerProjectionView.calloc(2);
+        try (MemoryStack stack = MemoryStack.stackPush()){
+
+            IntBuffer intBuf2 = stack.callocInt(1);
+
+            int error = XR10.xrAcquireSwapchainImage(
+                openxr.swapchain,
+                XrSwapchainImageAcquireInfo.calloc(stack).type(XR10.XR_TYPE_SWAPCHAIN_IMAGE_ACQUIRE_INFO),
+                intBuf2);
+            this.openxr.logError(error, "xrAcquireSwapchainImage", "");
+
+            error = XR10.xrWaitSwapchainImage(openxr.swapchain,
+                XrSwapchainImageWaitInfo.calloc(stack)
+                    .type(XR10.XR_TYPE_SWAPCHAIN_IMAGE_WAIT_INFO)
+                    .timeout(XR10.XR_INFINITE_DURATION));
+            this.openxr.logError(error, "xrWaitSwapchainImage", "");
+
+            this.swapIndex = intBuf2.get(0);
+
+            // Render view to the appropriate part of the swapchain image.
+            for (int viewIndex = 0; viewIndex < 2; viewIndex++) {
+
+                var subImage = projectionLayerViews.get(viewIndex)
+                    .type(XR10.XR_TYPE_COMPOSITION_LAYER_PROJECTION_VIEW)
+                    .pose(openxr.viewBuffer.get(viewIndex).pose())
+                    .fov(openxr.viewBuffer.get(viewIndex).fov())
+                    .subImage();
+                subImage.swapchain(openxr.swapchain);
+                subImage.imageRect().offset().set(0, 0);
+                subImage.imageRect().extent().set(openxr.width, openxr.height);
+                subImage.imageArrayIndex(viewIndex);
+
+            }
+        }
+    }
+
+    @Override
+    public Matrix4f getProjectionMatrix(int eyeType, float nearClip, float farClip) {
+        XrFovf fov = openxr.viewBuffer.get(eyeType).fov();
+        return new Matrix4f().setPerspectiveOffCenterFov(fov.angleLeft(), fov.angleRight(), fov.angleDown(), fov.angleUp(), nearClip, farClip);
+    }
+
+    @Override
+    public void endFrame() throws RenderConfigException {
+        GL31.glBindFramebuffer(GL31.GL_READ_FRAMEBUFFER, getLeftEyeTarget().frameBufferId);
+        GL31.glBindFramebuffer(GL31.GL_DRAW_FRAMEBUFFER, leftFramebuffers[swapIndex].frameBufferId);
+        GL31.glBlitFramebuffer(0,0, getLeftEyeTarget().viewWidth, getLeftEyeTarget().viewHeight, 0,0, leftFramebuffers[swapIndex].viewWidth, leftFramebuffers[swapIndex].viewHeight, GL31.GL_STENCIL_BUFFER_BIT | GL31.GL_COLOR_BUFFER_BIT, GL31.GL_NEAREST);
+
+        GL31.glBindFramebuffer(GL31.GL_READ_FRAMEBUFFER, getRightEyeTarget().frameBufferId);
+        GL31.glBindFramebuffer(GL31.GL_DRAW_FRAMEBUFFER, rightFramebuffers[swapIndex].frameBufferId);
+        GL31.glBlitFramebuffer(0,0, getRightEyeTarget().viewWidth, getRightEyeTarget().viewHeight, 0,0, rightFramebuffers[swapIndex].viewWidth, rightFramebuffers[swapIndex].viewHeight, GL31.GL_STENCIL_BUFFER_BIT | GL31.GL_COLOR_BUFFER_BIT, GL31.GL_NEAREST);
+
+        try (MemoryStack stack = MemoryStack.stackPush()){
+            PointerBuffer layers = stack.callocPointer(1);
+            int error;
+            if (this.openxr.shouldRender) {
+                error = XR10.xrReleaseSwapchainImage(
+                    openxr.swapchain,
+                    XrSwapchainImageReleaseInfo.calloc(stack)
+                        .type(XR10.XR_TYPE_SWAPCHAIN_IMAGE_RELEASE_INFO));
+                this.openxr.logError(error, "xrReleaseSwapchainImage", "");
+
+                XrCompositionLayerProjection compositionLayerProjection = XrCompositionLayerProjection.calloc(stack)
+                    .type(XR10.XR_TYPE_COMPOSITION_LAYER_PROJECTION)
+                    .space(openxr.xrAppSpace)
+                    .views(projectionLayerViews);
+
+                layers.put(compositionLayerProjection);
+            }
+            layers.flip();
+
+            error = XR10.xrEndFrame(
+                openxr.session,
+                XrFrameEndInfo.calloc(stack)
+                    .type(XR10.XR_TYPE_FRAME_END_INFO)
+                    .displayTime(openxr.time)
+                    .environmentBlendMode(XR10.XR_ENVIRONMENT_BLEND_MODE_OPAQUE)
+                    .layers(layers));
+            this.openxr.logAll(error, "xrEndFrame", "");
+
+            projectionLayerViews.close();
+        }
+    }
+
+    @Override
+    public boolean providesStencilMask() {
+        return false;
+    }
+
+    @Override
+    public RenderTarget getLeftEyeTarget() {
+        return leftFramebuffer;
+    }
+
+    @Override
+    public RenderTarget getRightEyeTarget() {
+        return rightFramebuffer;
+    }
+
+    @Override
+    public Tuple<Integer, Integer> getRenderTextureSizes() {
+        return new Tuple<>(openxr.width, openxr.height);
+    }
+}
Index: common/src/main/java/org/vivecraft/client_vr/provider/openxr/OpenXRUtil.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/src/main/java/org/vivecraft/client_vr/provider/openxr/OpenXRUtil.java b/common/src/main/java/org/vivecraft/client_vr/provider/openxr/OpenXRUtil.java
new file mode 100644
--- /dev/null	(revision a1131575d6931b12d3cb0b9f8a519b861bc5ca4c)
+++ b/common/src/main/java/org/vivecraft/client_vr/provider/openxr/OpenXRUtil.java	(revision a1131575d6931b12d3cb0b9f8a519b861bc5ca4c)
@@ -0,0 +1,50 @@
+package org.vivecraft.client_vr.provider.openxr;
+
+import org.joml.Matrix3f;
+import org.joml.Quaternionf;
+import org.lwjgl.openxr.XrPosef;
+import org.lwjgl.openxr.XrQuaternionf;
+import org.vivecraft.common.utils.math.Matrix4f;
+
+public class OpenXRUtil {
+
+    public static void openXRPoseToMarix(XrPosef pose, Matrix4f mat) {
+        Matrix3f matrix3f = new Matrix3f().set(new Quaternionf(pose.orientation().x(), pose.orientation().y(), pose.orientation().z(), pose.orientation().w()));
+        mat.M[0][0] = matrix3f.m00;
+        mat.M[0][1] = matrix3f.m10;
+        mat.M[0][2] = matrix3f.m20;
+        mat.M[0][3] = pose.position$().x();
+        mat.M[1][0] = matrix3f.m01;
+        mat.M[1][1] = matrix3f.m11;
+        mat.M[1][2] = matrix3f.m21;
+        mat.M[1][3] = pose.position$().y();
+        mat.M[2][0] = matrix3f.m02;
+        mat.M[2][1] = matrix3f.m12;
+        mat.M[2][2] = matrix3f.m22;
+        mat.M[2][3] = pose.position$().z();
+        mat.M[3][0] = 0;
+        mat.M[3][1] = 0;
+        mat.M[3][2] = 0;
+        mat.M[3][3] = 1;
+    }
+
+    public static void openXRPoseToMarix(XrQuaternionf quat, Matrix4f mat) {
+        Matrix3f matrix3f = new Matrix3f().set(new Quaternionf(quat.x(), quat.y(), quat.z(), quat.w()));
+        mat.M[0][0] = matrix3f.m00;
+        mat.M[0][1] = matrix3f.m10;
+        mat.M[0][2] = matrix3f.m20;
+        mat.M[0][3] = 0;
+        mat.M[1][0] = matrix3f.m01;
+        mat.M[1][1] = matrix3f.m11;
+        mat.M[1][2] = matrix3f.m21;
+        mat.M[1][3] = 0;
+        mat.M[2][0] = matrix3f.m02;
+        mat.M[2][1] = matrix3f.m12;
+        mat.M[2][2] = matrix3f.m22;
+        mat.M[2][3] = 0;
+        mat.M[3][0] = 0;
+        mat.M[3][1] = 0;
+        mat.M[3][2] = 0;
+        mat.M[3][3] = 1;
+    }
+}
Index: common/src/main/java/org/vivecraft/client_vr/provider/openxr/XRBindings.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/src/main/java/org/vivecraft/client_vr/provider/openxr/XRBindings.java b/common/src/main/java/org/vivecraft/client_vr/provider/openxr/XRBindings.java
new file mode 100644
--- /dev/null	(revision a1131575d6931b12d3cb0b9f8a519b861bc5ca4c)
+++ b/common/src/main/java/org/vivecraft/client_vr/provider/openxr/XRBindings.java	(revision a1131575d6931b12d3cb0b9f8a519b861bc5ca4c)
@@ -0,0 +1,137 @@
+package org.vivecraft.client_vr.provider.openxr;
+
+import org.apache.commons.lang3.tuple.MutablePair;
+import org.apache.commons.lang3.tuple.Pair;
+
+import java.util.HashSet;
+
+public class XRBindings {
+
+    public static HashSet<String> supportedHeadsets() {
+        HashSet<String> set = new HashSet<>();
+        if (MCOpenXR.get().systemName.toLowerCase().contains("oculus") || MCOpenXR.get().systemName.toLowerCase().contains("meta")) {
+            set.add("/interaction_profiles/oculus/touch_controller");
+            return set;
+        }
+        if (MCOpenXR.get().session.getCapabilities().XR_HTC_vive_cosmos_controller_interaction) {
+            set.add("/interaction_profiles/htc/vive_cosmos_controller");
+        }
+        set.add("/interaction_profiles/htc/vive_controller");
+        return set;
+    }
+
+    private static HashSet<Pair<String, String>> quest2Bindings() {
+        HashSet<Pair<String, String>> set = new HashSet<>();
+
+        set.add(new MutablePair<>("/actions/global/in/vivecraft.key.ingameMenuButton", "/user/hand/left/input/y/click"));
+        set.add(new MutablePair<>("/actions/global/in/vivecraft.key.toggleKeyboard", "/user/hand/left/input/squeeze"));
+        set.add(new MutablePair<>("/actions/global/in/key.inventory", "/user/hand/left/input/x/click"));
+
+        set.add(new MutablePair<>("/actions/gui/in/vivecraft.key.guiShift", "/user/hand/left/input/squeeze"));
+        set.add(new MutablePair<>("/actions/gui/in/vivecraft.key.guiMiddleClick", "/user/hand/right/input/squeeze"));
+        set.add(new MutablePair<>("/actions/gui/in/vivecraft.key.guiLeftClick", "/user/hand/right/input/trigger"));
+        set.add(new MutablePair<>("/actions/gui/in/vivecraft.key.guiRightClick", "/user/hand/right/input/a/click"));
+        set.add(new MutablePair<>("/actions/gui/in/vivecraft.key.guiScrollAxis", "/user/hand/right/input/thumbstick/y"));
+
+        set.add(new MutablePair<>("/actions/ingame/in/vivecraft.key.hotbarPrev", "/user/hand/left/input/squeeze"));
+        set.add(new MutablePair<>("/actions/ingame/in/vivecraft.key.hotbarNext", "/user/hand/right/input/squeeze"));
+        set.add(new MutablePair<>("/actions/ingame/in/key.attack", "/user/hand/right/input/trigger"));
+        set.add(new MutablePair<>("/actions/ingame/in/vivecraft.key.teleport", "/user/hand/left/input/trigger"));
+        set.add(new MutablePair<>("/actions/ingame/in/vivecraft.key.radialMenu", "/user/hand/right/input/b/click"));
+        set.add(new MutablePair<>("/actions/ingame/in/key.use", "/user/hand/right/input/a/click"));
+        set.add(new MutablePair<>("/actions/ingame/in/vivecraft.key.teleportFallback", "/user/hand/left/input/trigger/value"));
+        set.add(new MutablePair<>("/actions/ingame/in/key.jump", "/user/hand/left/input/thumbstick"));
+        set.add(new MutablePair<>("/actions/ingame/in/vivecraft.key.freeMoveStrafe", "/user/hand/left/input/thumbstick"));
+        set.add(new MutablePair<>("/actions/ingame/in/key.sneak", "/user/hand/right/input/thumbstick"));
+        set.add(new MutablePair<>("/actions/ingame/in/vivecraft.key.rotateAxis", "/user/hand/right/input/thumbstick"));
+
+        set.add(new MutablePair<>("/actions/keyboard/in/vivecraft.key.keyboardShift", "/user/hand/left/input/squeeze"));
+        set.add(new MutablePair<>("/actions/keyboard/in/vivecraft.key.keyboardShift", "/user/hand/right/input/squeeze"));
+        set.add(new MutablePair<>("/actions/keyboard/in/vivecraft.key.keyboardClick", "/user/hand/left/input/trigger"));
+        set.add(new MutablePair<>("/actions/keyboard/in/vivecraft.key.keyboardClick", "/user/hand/right/input/trigger"));
+        return set;
+    }
+
+    private static HashSet<Pair<String, String>> viveBindings() {
+        HashSet<Pair<String, String>> set = new HashSet<>();
+
+        set.add(new MutablePair<>("/actions/global/in/vivecraft.key.ingameMenuButton", "/user/hand/left/input/menu/click"));
+        set.add(new MutablePair<>("/actions/global/in/vivecraft.key.toggleKeyboard", "/user/hand/left/input/squeeze/click"));
+        set.add(new MutablePair<>("/actions/global/in/key.inventory", "/user/hand/right/input/trackpad/click"));
+
+        set.add(new MutablePair<>("/actions/gui/in/vivecraft.key.guiShift", "/user/hand/left/input/squeeze/click"));
+        set.add(new MutablePair<>("/actions/gui/in/vivecraft.key.guiMiddleClick", "/user/hand/right/input/squeeze/click"));
+        set.add(new MutablePair<>("/actions/gui/in/vivecraft.key.guiLeftClick", "/user/hand/right/input/trigger/click"));
+        set.add(new MutablePair<>("/actions/gui/in/vivecraft.key.guiRightClick", "/user/hand/right/input/trackpad/click"));
+        set.add(new MutablePair<>("/actions/gui/in/vivecraft.key.guiScrollAxis", "/user/hand/right/input/trackpad/y"));
+
+        set.add(new MutablePair<>("/actions/ingame/in/vivecraft.key.hotbarPrev", "/user/hand/left/input/squeeze/click"));
+        set.add(new MutablePair<>("/actions/ingame/in/vivecraft.key.hotbarNext", "/user/hand/right/input/squeeze/click"));
+        set.add(new MutablePair<>("/actions/ingame/in/key.attack", "/user/hand/right/input/trigger/click"));
+        set.add(new MutablePair<>("/actions/ingame/in/vivecraft.key.teleport", "/user/hand/left/input/trigger/click"));
+        set.add(new MutablePair<>("/actions/ingame/in/vivecraft.key.radialMenu", "/user/hand/right/input/menu/click"));
+        set.add(new MutablePair<>("/actions/ingame/in/key.use", "/user/hand/right/input/trackpad/click"));
+        set.add(new MutablePair<>("/actions/ingame/in/vivecraft.key.teleportFallback", "/user/hand/left/input/trigger/value"));
+        set.add(new MutablePair<>("/actions/ingame/in/key.jump", "/user/hand/left/input/trackpad/x"));
+        set.add(new MutablePair<>("/actions/ingame/in/vivecraft.key.freeMoveStrafe", "/user/hand/left/input/trackpad"));
+        set.add(new MutablePair<>("/actions/ingame/in/key.sneak", "/user/hand/left/input/trackpad/y"));
+        set.add(new MutablePair<>("/actions/ingame/in/vivecraft.key.rotateAxis", "/user/hand/right/input/trackpad"));
+
+        set.add(new MutablePair<>("/actions/keyboard/in/vivecraft.key.keyboardShift", "/user/hand/left/input/squeeze/click"));
+        set.add(new MutablePair<>("/actions/keyboard/in/vivecraft.key.keyboardClick", "/user/hand/left/input/trigger/click"));
+        set.add(new MutablePair<>("/actions/keyboard/in/vivecraft.key.keyboardClick", "/user/hand/right/input/trigger/click"));
+
+        set.add(new MutablePair<>("/actions/technical/in/vivecraft.key.trackpadTouch", "/user/hand/left/input/trackpad/click"));
+        set.add(new MutablePair<>("/actions/technical/in/vivecraft.key.trackpadTouch", "/user/hand/right/input/trackpad/touch"));
+
+        return set;
+    }
+
+    private static HashSet<Pair<String, String>> cosmosBindings() {
+        HashSet<Pair<String, String>> set = new HashSet<>();
+
+        set.add(new MutablePair<>("/actions/global/in/vivecraft.key.ingameMenuButton", "/user/hand/left/input/y/click"));
+        set.add(new MutablePair<>("/actions/global/in/vivecraft.key.toggleKeyboard", "/user/hand/left/input/y/long"));
+        set.add(new MutablePair<>("/actions/global/in/key.inventory", "/user/hand/left/input/x/click"));
+
+        set.add(new MutablePair<>("/actions/gui/in/vivecraft.key.guiShift", "/user/hand/left/input/grip/click"));
+        set.add(new MutablePair<>("/actions/gui/in/vivecraft.key.guiMiddleClick", "/user/hand/right/input/grip/click"));
+        set.add(new MutablePair<>("/actions/gui/in/vivecraft.key.guiLeftClick", "/user/hand/right/input/trigger/click"));
+        set.add(new MutablePair<>("/actions/gui/in/vivecraft.key.guiRightClick", "/user/hand/right/input/a/click"));
+        set.add(new MutablePair<>("/actions/gui/in/vivecraft.key.guiScrollAxis", "/user/hand/right/input/joystick/scroll"));
+
+        set.add(new MutablePair<>("/actions/ingame/in/vivecraft.key.hotbarPrev", "/user/hand/left/input/grip/click"));
+        set.add(new MutablePair<>("/actions/ingame/in/vivecraft.key.hotbarNext", "/user/hand/right/input/grip/click"));
+        set.add(new MutablePair<>("/actions/ingame/in/key.attack", "/user/hand/right/input/trigger/click"));
+        set.add(new MutablePair<>("/actions/ingame/in/vivecraft.key.teleport", "/user/hand/left/input/trigger/click"));
+        set.add(new MutablePair<>("/actions/ingame/in/vivecraft.key.radialMenu", "/user/hand/right/input/b/click"));
+        set.add(new MutablePair<>("/actions/ingame/in/key.use", "/user/hand/right/input/a/click"));
+        set.add(new MutablePair<>("/actions/ingame/in/vivecraft.key.freeMoveStrafe", "/user/hand/left/input/joystick/position"));
+        set.add(new MutablePair<>("/actions/ingame/in/vivecraft.key.rotateAxis", "/user/hand/right/input/joystick/position"));
+        set.add(new MutablePair<>("/actions/ingame/in/vivecraft.key.teleportFallback", "/user/hand/left/input/trigger/pull"));
+        set.add(new MutablePair<>("/actions/ingame/in/key.jump", "/user/hand/left/input/bumper/click"));
+        set.add(new MutablePair<>("/actions/ingame/in/key.sneak", "/user/hand/right/input/bumper/click"));
+
+        set.add(new MutablePair<>("/actions/keyboard/in/vivecraft.key.keyboardShift", "/user/hand/left/input/grip/click"));
+        set.add(new MutablePair<>("/actions/keyboard/in/vivecraft.key.keyboardClick", "/user/hand/left/input/trigger/click"));
+        set.add(new MutablePair<>("/actions/keyboard/in/vivecraft.key.keyboardClick", "/user/hand/right/input/trigger/click"));
+        return set;
+    }
+
+    public static HashSet<Pair<String, String>> getBinding(String Headset){
+        switch (Headset) {
+            case "/interaction_profiles/htc/vive_cosmos_controller" -> {
+                return cosmosBindings();
+            }
+            case "/interaction_profiles/htc/vive_controller" -> {
+                return viveBindings();
+            }
+            case "/interaction_profiles/oculus/touch_controller" -> {
+                return quest2Bindings();
+            }
+            default -> {
+                return viveBindings();
+            }
+        }
+    }
+}
Index: common/src/main/java/org/vivecraft/client_vr/render/VRShaders.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/src/main/java/org/vivecraft/client_vr/render/VRShaders.java b/common/src/main/java/org/vivecraft/client_vr/render/VRShaders.java
--- a/common/src/main/java/org/vivecraft/client_vr/render/VRShaders.java	(revision eaec65274edbf6dec8d28b76e7403b21c6b3145b)
+++ b/common/src/main/java/org/vivecraft/client_vr/render/VRShaders.java	(revision a1131575d6931b12d3cb0b9f8a519b861bc5ca4c)
@@ -34,6 +34,8 @@
     public static AbstractUniform _Overlay_time;
     public static AbstractUniform _Overlay_BlackAlpha;
     public static AbstractUniform _Overlay_eye;
+    public static ShaderInstance gsrShader;
+    public static AbstractUniform ViewportInfo;
 
     public static ShaderInstance rendertypeEndPortalShaderVR;
     public static ShaderInstance rendertypeEndGatewayShaderVR;
@@ -49,6 +51,12 @@
     private VRShaders() {
     }
 
+    public static void setupGSR() throws Exception {
+        gsrShader = new ShaderInstance(Minecraft.getInstance().getResourceManager(), "gsr", DefaultVertexFormat.POSITION_TEX);
+
+        ViewportInfo = gsrShader.safeGetUniform("ViewportInfo");
+    }
+
     public static void setupDepthMask() throws Exception {
         depthMaskShader = new ShaderInstance(Minecraft.getInstance().getResourceManager(), "mixedreality", DefaultVertexFormat.POSITION_TEX);
 
Index: common/src/main/java/org/vivecraft/client_vr/render/helpers/VRPassHelper.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/src/main/java/org/vivecraft/client_vr/render/helpers/VRPassHelper.java b/common/src/main/java/org/vivecraft/client_vr/render/helpers/VRPassHelper.java
--- a/common/src/main/java/org/vivecraft/client_vr/render/helpers/VRPassHelper.java	(revision eaec65274edbf6dec8d28b76e7403b21c6b3145b)
+++ b/common/src/main/java/org/vivecraft/client_vr/render/helpers/VRPassHelper.java	(revision a1131575d6931b12d3cb0b9f8a519b861bc5ca4c)
@@ -43,9 +43,9 @@
             if (dataHolder.vrSettings.useFsaa) {
                 RenderSystem.clearColor(RenderSystem.getShaderFogColor()[0], RenderSystem.getShaderFogColor()[1], RenderSystem.getShaderFogColor()[2], RenderSystem.getShaderFogColor()[3]);
                 if (eye == RenderPass.LEFT) {
-                    dataHolder.vrRenderer.framebufferEye0.bindWrite(true);
+                    dataHolder.vrRenderer.getLeftEyeTarget().bindWrite(true);
                 } else {
-                    dataHolder.vrRenderer.framebufferEye1.bindWrite(true);
+                    dataHolder.vrRenderer.getRightEyeTarget().bindWrite(true);
                 }
                 RenderSystem.clear(16384, Minecraft.ON_OSX);
                 mc.getProfiler().push("fsaa");
@@ -56,9 +56,9 @@
             }
 
             if (eye == RenderPass.LEFT) {
-                dataHolder.vrRenderer.framebufferEye0.bindWrite(true);
+                dataHolder.vrRenderer.getLeftEyeTarget().bindWrite(true);
             } else {
-                dataHolder.vrRenderer.framebufferEye1.bindWrite(true);
+                dataHolder.vrRenderer.getRightEyeTarget().bindWrite(true);
             }
 
             if (dataHolder.vrSettings.useFOVReduction
@@ -185,10 +185,16 @@
             VRShaders._Overlay_pumpkinAmplitutde.set(dataHolder.pumpkineffect);
 
             VRShaders._Overlay_eye.set(dataHolder.currentPass == RenderPass.LEFT ? 1 : -1);
-            ((RenderTargetExtension) rendertarget).vivecraft$blitFovReduction(VRShaders.fovReductionShader, dataHolder.vrRenderer.framebufferEye0.viewWidth, dataHolder.vrRenderer.framebufferEye0.viewHeight);
+
+            ((RenderTargetExtension) rendertarget).vivecraft$blitFovReduction(VRShaders.fovReductionShader, dataHolder.vrRenderer.getLeftEyeTarget().viewWidth, dataHolder.vrRenderer.getLeftEyeTarget().viewHeight);
             ProgramManager.glUseProgram(0);
             checkGLError("post overlay" + eye);
             mc.getProfiler().pop();
+
+            VRShaders.ViewportInfo.setSafe(0.0f, 0.0f,  dataHolder.vrRenderer.getLeftEyeTarget().viewWidth, dataHolder.vrRenderer.getRightEyeTarget().viewHeight);
+            ((RenderTargetExtension) rendertarget).vivecraft$blitToScreen(VRShaders.gsrShader, 0, dataHolder.vrRenderer.getLeftEyeTarget().viewWidth, dataHolder.vrRenderer.getLeftEyeTarget().viewHeight, 0, false, 0,  0, true);
+            ProgramManager.glUseProgram(0);
+            checkGLError("post gsr" + eye);
         }
 
         if (dataHolder.currentPass == RenderPass.CAMERA) {
Index: common/src/main/java/org/vivecraft/client_vr/settings/VRSettings.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/src/main/java/org/vivecraft/client_vr/settings/VRSettings.java b/common/src/main/java/org/vivecraft/client_vr/settings/VRSettings.java
--- a/common/src/main/java/org/vivecraft/client_vr/settings/VRSettings.java	(revision eaec65274edbf6dec8d28b76e7403b21c6b3145b)
+++ b/common/src/main/java/org/vivecraft/client_vr/settings/VRSettings.java	(revision a1131575d6931b12d3cb0b9f8a519b861bc5ca4c)
@@ -144,6 +144,7 @@
 
     public enum VRProvider implements OptionEnum<VRProvider> {
         OPENVR,
+        OPENXR,
         NULLVR
     }
 
@@ -452,13 +453,13 @@
     @SettingField(VrOptions.CHAT_MESSAGE_STENCIL)
     public boolean showChatMessageStencil = true;
     @SettingField(value = VrOptions.VR_ENABLED, config = "vrEnabled")
-    public boolean vrEnabled = false;
+    public boolean vrEnabled = true;
     @SettingField(VrOptions.VR_REMEMBER_ENABLED)
     public boolean rememberVr = true;
     @SettingField(VrOptions.VR_HOTSWITCH)
-    public boolean vrHotswitchingEnabled = true;
+    public boolean vrHotswitchingEnabled = false;
     @SettingField(value = VrOptions.VR_TOGGLE_BUTTON_VISIBLE, config = "vrToggleButtonEnabled")
-    public boolean vrToggleButtonEnabled = true;
+    public boolean vrToggleButtonEnabled = false;
     @SettingField(value = VrOptions.VR_SETTINGS_BUTTON_VISIBLE, config = "vrSettingsButtonEnabled")
     public boolean vrSettingsButtonEnabled = true;
     @SettingField(value = VrOptions.VR_SETTINGS_BUTTON_POSITION, config = "vrSettingsButtonPositionLeft")
@@ -1059,7 +1060,15 @@
 
     public enum VrOptions {
         DUMMY(false, true), // Dummy
-        VR_PLUGIN(false, true), // vr plugin to use
+        VR_PLUGIN(false, true) { // vr plugin to use
+            @Override
+            void onOptionChange() {
+                if (VRState.vrRunning) {
+                    VRState.destroyVR(false);
+                    VRState.vrEnabled = true;
+                }
+            }
+        },
         VR_ENABLED(false, true) { // vr or nonvr
 
             @Override
@@ -1564,7 +1573,7 @@
             @Override
             String getDisplayString(String prefix, Object value) {
                 if (VRState.vrEnabled) {
-                    RenderTarget eye0 = ClientDataHolderVR.getInstance().vrRenderer.framebufferEye0;
+                    RenderTarget eye0 = ClientDataHolderVR.getInstance().vrRenderer.getLeftEyeTarget();
                     return prefix + Math.round((float) value * 100) + "% (" + (int) Math.ceil(eye0.viewWidth * Math.sqrt((float) value)) + "x" + (int) Math.ceil(eye0.viewHeight * Math.sqrt((float) value)) + ")";
                 } else {
                     return prefix + Math.round((float) value * 100) + "%";
@@ -1754,6 +1763,7 @@
             }
         },
         INGAME_BINDINGS_IN_GUI(false, true),
+
         RADIAL_NUMBER(false, false,4, 14, 2, 0),
         RIGHT_CLICK_DELAY(false, false); // Right Click Repeat
 //        ANISOTROPIC_FILTERING("options.anisotropicFiltering", true, false, 1.0F, 16.0F, 0.0F)
Index: common/src/main/java/org/vivecraft/mixin/client/blaze3d/RenderTargetMixin.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/src/main/java/org/vivecraft/mixin/client/blaze3d/RenderTargetMixin.java b/common/src/main/java/org/vivecraft/mixin/client/blaze3d/RenderTargetMixin.java
--- a/common/src/main/java/org/vivecraft/mixin/client/blaze3d/RenderTargetMixin.java	(revision eaec65274edbf6dec8d28b76e7403b21c6b3145b)
+++ b/common/src/main/java/org/vivecraft/mixin/client/blaze3d/RenderTargetMixin.java	(revision a1131575d6931b12d3cb0b9f8a519b861bc5ca4c)
@@ -56,6 +56,11 @@
         this.vivecraft$texid = texid;
     }
 
+    @Override
+    public void vivecraft$setColorid(int colorid) {
+        this.colorTextureId = colorid;
+    }
+
     @Override
     public void vivecraft$isLinearFilter(boolean linearFilter) {
         this.vivecraft$linearFilter = linearFilter;
Index: common/src/main/java/org/vivecraft/mixin/client_vr/KeyboardInputVRMixin.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/src/main/java/org/vivecraft/mixin/client_vr/KeyboardInputVRMixin.java b/common/src/main/java/org/vivecraft/mixin/client_vr/KeyboardInputVRMixin.java
--- a/common/src/main/java/org/vivecraft/mixin/client_vr/KeyboardInputVRMixin.java	(revision eaec65274edbf6dec8d28b76e7403b21c6b3145b)
+++ b/common/src/main/java/org/vivecraft/mixin/client_vr/KeyboardInputVRMixin.java	(revision a1131575d6931b12d3cb0b9f8a519b861bc5ca4c)
@@ -16,10 +16,10 @@
 import org.vivecraft.client_vr.ClientDataHolderVR;
 import org.vivecraft.client_vr.VRState;
 import org.vivecraft.client_vr.gameplay.screenhandlers.KeyboardHandler;
-import org.vivecraft.client_vr.provider.openvr_lwjgl.VRInputAction;
+import org.vivecraft.client_vr.provider.control.VRInputAction;
 import org.vivecraft.common.utils.math.Vector2;
 
-import static org.vivecraft.client_vr.provider.openvr_lwjgl.control.VivecraftMovementInput.getMovementAxisValue;
+import static org.vivecraft.client_vr.provider.control.VivecraftMovementInput.getMovementAxisValue;
 
 @Mixin(KeyboardInput.class)
 public class KeyboardInputVRMixin extends Input {
Index: common/src/main/java/org/vivecraft/mixin/client_vr/MinecraftVRMixin.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/src/main/java/org/vivecraft/mixin/client_vr/MinecraftVRMixin.java b/common/src/main/java/org/vivecraft/mixin/client_vr/MinecraftVRMixin.java
--- a/common/src/main/java/org/vivecraft/mixin/client_vr/MinecraftVRMixin.java	(revision eaec65274edbf6dec8d28b76e7403b21c6b3145b)
+++ b/common/src/main/java/org/vivecraft/mixin/client_vr/MinecraftVRMixin.java	(revision a1131575d6931b12d3cb0b9f8a519b861bc5ca4c)
@@ -68,7 +68,7 @@
 import org.vivecraft.client_vr.gameplay.trackers.TelescopeTracker;
 import org.vivecraft.client_vr.menuworlds.MenuWorldDownloader;
 import org.vivecraft.client_vr.menuworlds.MenuWorldExporter;
-import org.vivecraft.client_vr.provider.openvr_lwjgl.VRInputAction;
+import org.vivecraft.client_vr.provider.control.VRInputAction;
 import org.vivecraft.client_vr.render.RenderConfigException;
 import org.vivecraft.client_vr.render.RenderPass;
 import org.vivecraft.client_vr.render.VRFirstPersonArmSwing;
@@ -301,7 +301,7 @@
         if (!VRState.vrInitialized) {
             return;
         }
-        boolean vrActive = !ClientDataHolderVR.getInstance().vrSettings.vrHotswitchingEnabled || ClientDataHolderVR.getInstance().vr.isActive();
+        boolean vrActive = ClientDataHolderVR.getInstance().vr.isActive() || !ClientDataHolderVR.getInstance().vrSettings.vrHotswitchingEnabled;
         if (VRState.vrRunning != vrActive && (ClientNetworking.serverAllowsVrSwitching || player == null)) {
             vivecraft$switchVRState(vrActive);
         }
@@ -361,7 +361,7 @@
             this.profiler.push("setupRenderConfiguration");
             try {
                 this.vivecraft$checkGLError("pre render setup ");
-                ClientDataHolderVR.getInstance().vrRenderer.setupRenderConfiguration();
+                ClientDataHolderVR.getInstance().vrRenderer.setupRenderConfiguration(true);
                 this.vivecraft$checkGLError("post render setup ");
             } catch (RenderConfigException renderConfigException) {
                 vivecraft$switchVRState(false);
@@ -983,8 +983,8 @@
                 this.vivecraft$notifyMirror("Shader compile failed, see log", true, 10000);
             }
         } else if (ClientDataHolderVR.getInstance().vrSettings.displayMirrorMode == VRSettings.MirrorMode.DUAL) {
-            RenderTarget rendertarget = ClientDataHolderVR.getInstance().vrRenderer.framebufferEye0;
-            RenderTarget rendertarget1 = ClientDataHolderVR.getInstance().vrRenderer.framebufferEye1;
+            RenderTarget rendertarget = ClientDataHolderVR.getInstance().vrRenderer.getLeftEyeTarget();
+            RenderTarget rendertarget1 = ClientDataHolderVR.getInstance().vrRenderer.getRightEyeTarget();
 
             int screenWidth = ((WindowExtension) (Object) this.window).vivecraft$getActualScreenWidth() / 2;
             int screenHeight = ((WindowExtension) (Object) this.window).vivecraft$getActualScreenHeight();
@@ -1001,7 +1001,7 @@
             float xcrop = 0.0F;
             float ycrop = 0.0F;
             boolean ar = false;
-            RenderTarget source = ClientDataHolderVR.getInstance().vrRenderer.framebufferEye0;
+            RenderTarget source = ClientDataHolderVR.getInstance().vrRenderer.getLeftEyeTarget();
 
             if (ClientDataHolderVR.getInstance().vrSettings.displayMirrorMode == VRSettings.MirrorMode.FIRST_PERSON) {
                 source = ClientDataHolderVR.getInstance().vrRenderer.framebufferUndistorted;
@@ -1012,11 +1012,11 @@
             } else if (ClientDataHolderVR.getInstance().vrSettings.displayMirrorMode == VRSettings.MirrorMode.SINGLE
                 || ClientDataHolderVR.getInstance().vrSettings.displayMirrorMode == VRSettings.MirrorMode.OFF) {
                 if (!ClientDataHolderVR.getInstance().vrSettings.displayMirrorLeftEye) {
-                    source = ClientDataHolderVR.getInstance().vrRenderer.framebufferEye1;
+                    source = ClientDataHolderVR.getInstance().vrRenderer.getRightEyeTarget();
                 }
             } else if (ClientDataHolderVR.getInstance().vrSettings.displayMirrorMode == VRSettings.MirrorMode.CROPPED) {
                 if (!ClientDataHolderVR.getInstance().vrSettings.displayMirrorLeftEye) {
-                    source = ClientDataHolderVR.getInstance().vrRenderer.framebufferEye1;
+                    source = ClientDataHolderVR.getInstance().vrRenderer.getRightEyeTarget();
                 }
 
                 xcrop = ClientDataHolderVR.getInstance().vrSettings.mirrorCrop;
@@ -1084,10 +1084,10 @@
             } else {
                 if (ClientDataHolderVR.getInstance().vrSettings.displayMirrorLeftEye) {
                     RenderSystem.setShaderTexture(2,
-                        ClientDataHolderVR.getInstance().vrRenderer.framebufferEye0.getColorTextureId());
+                        ClientDataHolderVR.getInstance().vrRenderer.getLeftEyeTarget().getColorTextureId());
                 } else {
                     RenderSystem.setShaderTexture(2,
-                        ClientDataHolderVR.getInstance().vrRenderer.framebufferEye1.getColorTextureId());
+                        ClientDataHolderVR.getInstance().vrRenderer.getRightEyeTarget().getColorTextureId());
                 }
             }
             VRShaders.depthMaskShader.setSampler("firstPersonColor", RenderSystem.getShaderTexture(2));
Index: common/src/main/java/org/vivecraft/mixin/client_vr/OpenVRMixin.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/src/main/java/org/vivecraft/mixin/client_vr/OpenVRMixin.java b/common/src/main/java/org/vivecraft/mixin/client_vr/OpenVRMixin.java
new file mode 100644
--- /dev/null	(revision a1131575d6931b12d3cb0b9f8a519b861bc5ca4c)
+++ b/common/src/main/java/org/vivecraft/mixin/client_vr/OpenVRMixin.java	(revision a1131575d6931b12d3cb0b9f8a519b861bc5ca4c)
@@ -0,0 +1,67 @@
+package org.vivecraft.mixin.client_vr;
+
+import org.lwjgl.openvr.OpenVR;
+import org.spongepowered.asm.mixin.Mixin;
+import org.spongepowered.asm.mixin.Overwrite;
+import org.spongepowered.asm.mixin.Shadow;
+
+import javax.annotation.Nullable;
+import java.util.function.LongFunction;
+
+import static org.lwjgl.openvr.VR.*;
+
+@Mixin(value = OpenVR.class, remap = false)
+public abstract class OpenVRMixin {
+    @Shadow @Nullable public static OpenVR.IVRSystem VRSystem;
+    @Shadow @Nullable public static OpenVR.IVRChaperone VRChaperone;
+    @Shadow @Nullable public static OpenVR.IVRChaperoneSetup VRChaperoneSetup;
+    @Shadow @Nullable public static OpenVR.IVRCompositor VRCompositor;
+    @Shadow @Nullable public static OpenVR.IVROverlay VROverlay;
+    @Shadow @Nullable public static OpenVR.IVRResources VRResources;
+    @Shadow @Nullable public static OpenVR.IVRRenderModels VRRenderModels;
+    @Shadow @Nullable public static OpenVR.IVRExtendedDisplay VRExtendedDisplay;
+    @Shadow @Nullable public static OpenVR.IVRSettings VRSettings;
+    @Shadow @Nullable public static OpenVR.IVRApplications VRApplications;
+    @Shadow @Nullable public static OpenVR.IVRTrackedCamera VRTrackedCamera;
+    @Shadow @Nullable public static OpenVR.IVRScreenshots VRScreenshots;
+    @Shadow @Nullable public static OpenVR.IVRDriverManager VRDriverManager;
+    @Shadow @Nullable public static OpenVR.IVRInput VRInput;
+    @Shadow @Nullable public static OpenVR.IVRIOBuffer VRIOBuffer;
+    @Shadow @Nullable public static OpenVR.IVRSpatialAnchors VRSpatialAnchors;
+    @Shadow @Nullable public static OpenVR.IVRNotifications VRNotifications;
+    @Shadow private static int token;
+
+    @Shadow
+    @Nullable
+    private static <T> T getGenericInterface(String interfaceNameVersion, LongFunction<T> supplier) {
+        return null;
+    }
+
+    /**
+     * @author
+     * @reason
+     */
+    @Overwrite
+    public static void create(int tok) {
+        token = tok;
+
+        VRSystem = getGenericInterface(IVRSystem_Version, OpenVR.IVRSystem::new);
+        VRChaperone = getGenericInterface(IVRChaperone_Version, OpenVR.IVRChaperone::new);
+        VRChaperoneSetup = getGenericInterface(IVRChaperoneSetup_Version, OpenVR.IVRChaperoneSetup::new);
+        VRCompositor = getGenericInterface(IVRCompositor_Version, OpenVR.IVRCompositor::new);
+        VROverlay = getGenericInterface(IVROverlay_Version, OpenVR.IVROverlay::new);
+        // VRResources = getGenericInterface(IVRResources_Version, OpenVR.IVRResources::new);
+        VRRenderModels = getGenericInterface(IVRRenderModels_Version, OpenVR.IVRRenderModels::new);
+        VRExtendedDisplay = getGenericInterface(IVRExtendedDisplay_Version, OpenVR.IVRExtendedDisplay::new);
+        VRSettings = getGenericInterface(IVRSettings_Version, OpenVR.IVRSettings::new);
+        VRApplications = getGenericInterface(IVRApplications_Version, OpenVR.IVRApplications::new);
+        // VRTrackedCamera = getGenericInterface(IVRTrackedCamera_Version, OpenVR.IVRTrackedCamera::new);
+        VRScreenshots = getGenericInterface(IVRScreenshots_Version, OpenVR.IVRScreenshots::new);
+        // VRDriverManager = getGenericInterface(IVRDriverManager_Version, OpenVR.IVRDriverManager::new);
+        VRInput = getGenericInterface(IVRInput_Version, OpenVR.IVRInput::new);
+        // VRIOBuffer = getGenericInterface(IVRIOBuffer_Version, OpenVR.IVRIOBuffer::new);
+        // VRSpatialAnchors = getGenericInterface(IVRSpatialAnchors_Version, OpenVR.IVRSpatialAnchors::new);
+        // VRDebug = getGenericInterface(IVRDebug_Version, OpenVR.IVRDebug::new);
+        // VRNotifications = getGenericInterface(IVRNotifications_Version, OpenVR.IVRNotifications::new);
+    }
+}
Index: common/src/main/java/org/vivecraft/mixin/server/ServerPlayerMixin.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/src/main/java/org/vivecraft/mixin/server/ServerPlayerMixin.java b/common/src/main/java/org/vivecraft/mixin/server/ServerPlayerMixin.java
--- a/common/src/main/java/org/vivecraft/mixin/server/ServerPlayerMixin.java	(revision eaec65274edbf6dec8d28b76e7403b21c6b3145b)
+++ b/common/src/main/java/org/vivecraft/mixin/server/ServerPlayerMixin.java	(revision a1131575d6931b12d3cb0b9f8a519b861bc5ca4c)
@@ -239,13 +239,13 @@
                 entity = damageSource.getEntity().getName().plainCopy().getString();
                 // death by mob
                 if (vivePlayer == null) {
-                    message = ServerConfig.messagesDeathByMobVanilla.get();
+                    message = ServerConfig.messagesDeathVanilla.get();
                 } else if (!vivePlayer.isVR()) {
-                    message = ServerConfig.messagesDeathByMobNonVR.get();
+                    message = ServerConfig.messagesDeathNonVR.get();
                 } else if (vivePlayer.isSeated()) {
-                    message = ServerConfig.messagesDeathByMobSeated.get();
+                    message = ServerConfig.messagesDeathSeated.get();
                 } else {
-                    message = ServerConfig.messagesDeathByMobVR.get();
+                    message = ServerConfig.messagesDeathVR.get();
                 }
             }
 
Index: common/src/main/java/org/vivecraft/util/VLoader.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/src/main/java/org/vivecraft/util/VLoader.java b/common/src/main/java/org/vivecraft/util/VLoader.java
new file mode 100644
--- /dev/null	(revision a1131575d6931b12d3cb0b9f8a519b861bc5ca4c)
+++ b/common/src/main/java/org/vivecraft/util/VLoader.java	(revision a1131575d6931b12d3cb0b9f8a519b861bc5ca4c)
@@ -0,0 +1,14 @@
+package org.vivecraft.util;
+
+public class VLoader {
+    static {
+        System.loadLibrary("vloader");
+    }
+
+    public static native long getEGLDisp();
+    public static native long getEGLCfg();
+    public static native long getEGLCtx();
+
+    public static native long getJVMPtr();
+    public static native long getActivityPtr();
+}
Index: common/src/main/resources/assets/minecraft/shaders/core/fovreduction.fsh
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/src/main/resources/assets/minecraft/shaders/core/fovreduction.fsh b/common/src/main/resources/assets/minecraft/shaders/core/fovreduction.fsh
--- a/common/src/main/resources/assets/minecraft/shaders/core/fovreduction.fsh	(revision eaec65274edbf6dec8d28b76e7403b21c6b3145b)
+++ b/common/src/main/resources/assets/minecraft/shaders/core/fovreduction.fsh	(revision a1131575d6931b12d3cb0b9f8a519b861bc5ca4c)
@@ -2,7 +2,7 @@
 
 uniform sampler2D Sampler0;
 uniform float circle_radius;
-uniform float circle_offset = 0.1;
+uniform float circle_offset;
 uniform float border;
 
 uniform float water;
@@ -22,7 +22,7 @@
 const vec4 orange = vec4(.25, .125, 0, 1.0);
 const float pi = 3.14159265;
 
-uniform int eye = 0;
+uniform int eye;
 
 void main(){
 
Index: common/src/main/resources/assets/minecraft/shaders/core/fovreduction.vsh
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/src/main/resources/assets/minecraft/shaders/core/fovreduction.vsh b/common/src/main/resources/assets/minecraft/shaders/core/fovreduction.vsh
--- a/common/src/main/resources/assets/minecraft/shaders/core/fovreduction.vsh	(revision eaec65274edbf6dec8d28b76e7403b21c6b3145b)
+++ b/common/src/main/resources/assets/minecraft/shaders/core/fovreduction.vsh	(revision a1131575d6931b12d3cb0b9f8a519b861bc5ca4c)
@@ -7,5 +7,5 @@
 out vec2 texCoordinates;
 void main() {
     gl_Position = ProjMat * ModelViewMat * vec4(Position, 1.0);
-    texCoordinates = UV0;
+    texCoordinates = vec2(UV0.s, 1.0 - UV0.t);
 }
Index: common/src/main/resources/assets/minecraft/shaders/core/gsr.fsh
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/src/main/resources/assets/minecraft/shaders/core/gsr.fsh b/common/src/main/resources/assets/minecraft/shaders/core/gsr.fsh
new file mode 100644
--- /dev/null	(revision a1131575d6931b12d3cb0b9f8a519b861bc5ca4c)
+++ b/common/src/main/resources/assets/minecraft/shaders/core/gsr.fsh	(revision a1131575d6931b12d3cb0b9f8a519b861bc5ca4c)
@@ -0,0 +1,142 @@
+#version 450 core
+
+//============================================================================================================
+//
+//
+//                  Copyright (c) 2023, Qualcomm Innovation Center, Inc. All rights reserved.
+//                              SPDX-License-Identifier: BSD-3-Clause
+//
+//============================================================================================================
+
+precision mediump float;
+precision highp int;
+
+////////////////////////
+// USER CONFIGURATION //
+////////////////////////
+
+/*
+* Operation modes:
+* RGBA -> 1
+* RGBY -> 3
+* LERP -> 4
+*/
+#define OperationMode 1
+
+#define EdgeThreshold 4.0/255.0
+
+#define EdgeSharpness 2.0
+
+// #define UseUniformBlock
+
+////////////////////////
+////////////////////////
+////////////////////////
+
+#if defined(UseUniformBlock)
+layout (set=0, binding = 0) uniform UniformBlock
+{
+	highp vec4 ViewportInfo[1];
+};
+layout(set = 0, binding = 1) uniform mediump sampler2D Sampler0;
+#else
+uniform vec4 ViewportInfo[1];
+uniform sampler2D Sampler0;
+#endif
+
+in vec2 texCoordinates;
+out vec4 fragColor;
+
+float fastLanczos2(float x)
+{
+	float wA = x-4.0;
+	float wB = x*wA-wA;
+	wA *= wA;
+	return wB*wA;
+}
+vec2 weightY(float dx, float dy,float c, float std)
+{
+	float x = ((dx*dx)+(dy* dy))* 0.55 + clamp(abs(c)*std, 0.0, 1.0);
+	float w = fastLanczos2(x);
+	return vec2(w, w * c);
+}
+
+void main()
+{
+	const int mode = OperationMode;
+	float edgeThreshold = EdgeThreshold;
+	float edgeSharpness = EdgeSharpness;
+
+	vec4 color;
+	if(mode == 1)
+		color.xyz = textureLod(Sampler0,texCoordinates.xy,0.0).xyz;
+	else
+		color.xyzw = textureLod(Sampler0,texCoordinates.xy,0.0).xyzw;
+
+	float xCenter;
+	xCenter = abs(texCoordinates.x+-0.5);
+	float yCenter;
+	yCenter = abs(texCoordinates.y+-0.5);
+
+	//todo: config the SR region based on needs
+	//if ( mode!=4 && xCenter*xCenter+yCenter*yCenter<=0.4 * 0.4)
+	if ( mode!=4)
+	{
+		vec2 imgCoord = ((texCoordinates.xy*ViewportInfo[0].zw)+vec2(-0.5,0.5));
+		vec2 imgCoordPixel = floor(imgCoord);
+		vec2 coord = (imgCoordPixel*ViewportInfo[0].xy);
+		vec2 pl = (imgCoord+(-imgCoordPixel));
+		vec4 left = textureGather(Sampler0,coord, mode);
+
+		float edgeVote = abs(left.z - left.y) + abs(color[mode] - left.y)  + abs(color[mode] - left.z) ;
+		if(edgeVote > edgeThreshold)
+		{
+			coord.x += ViewportInfo[0].x;
+
+			vec4 right = textureGather(Sampler0,coord + vec2(ViewportInfo[0].x, 0.0), mode);
+			vec4 upDown;
+			upDown.xy = textureGather(Sampler0,coord + vec2(0.0, -ViewportInfo[0].y),mode).wz;
+			upDown.zw  = textureGather(Sampler0,coord+ vec2(0.0, ViewportInfo[0].y), mode).yx;
+
+			float mean = (left.y+left.z+right.x+right.w)*0.25;
+			left = left - vec4(mean);
+			right = right - vec4(mean);
+			upDown = upDown - vec4(mean);
+			color.w =color[mode] - mean;
+
+			float sum = (((((abs(left.x)+abs(left.y))+abs(left.z))+abs(left.w))+(((abs(right.x)+abs(right.y))+abs(right.z))+abs(right.w)))+(((abs(upDown.x)+abs(upDown.y))+abs(upDown.z))+abs(upDown.w)));
+			float std = 2.181818/sum;
+
+			vec2 aWY = weightY(pl.x, pl.y+1.0, upDown.x,std);
+			aWY += weightY(pl.x-1.0, pl.y+1.0, upDown.y,std);
+			aWY += weightY(pl.x-1.0, pl.y-2.0, upDown.z,std);
+			aWY += weightY(pl.x, pl.y-2.0, upDown.w,std);
+			aWY += weightY(pl.x+1.0, pl.y-1.0, left.x,std);
+			aWY += weightY(pl.x, pl.y-1.0, left.y,std);
+			aWY += weightY(pl.x, pl.y, left.z,std);
+			aWY += weightY(pl.x+1.0, pl.y, left.w,std);
+			aWY += weightY(pl.x-1.0, pl.y-1.0, right.x,std);
+			aWY += weightY(pl.x-2.0, pl.y-1.0, right.y,std);
+			aWY += weightY(pl.x-2.0, pl.y, right.z,std);
+			aWY += weightY(pl.x-1.0, pl.y, right.w,std);
+
+			float finalY = aWY.y/aWY.x;
+
+			float maxY = max(max(left.y,left.z),max(right.x,right.w));
+			float minY = min(min(left.y,left.z),min(right.x,right.w));
+			finalY = clamp(edgeSharpness*finalY, minY, maxY);
+
+			float deltaY = finalY -color.w;
+
+			//smooth high contrast input
+			deltaY = clamp(deltaY, -23.0 / 255.0, 23.0 / 255.0);
+
+			color.x = clamp((color.x+deltaY),0.0,1.0);
+			color.y = clamp((color.y+deltaY),0.0,1.0);
+			color.z = clamp((color.z+deltaY),0.0,1.0);
+		}
+	}
+
+	color.w = 1.0;  //assume alpha channel is not used
+	fragColor.xyzw = color;
+}
Index: common/src/main/resources/assets/minecraft/shaders/core/gsr.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/src/main/resources/assets/minecraft/shaders/core/gsr.json b/common/src/main/resources/assets/minecraft/shaders/core/gsr.json
new file mode 100644
--- /dev/null	(revision a1131575d6931b12d3cb0b9f8a519b861bc5ca4c)
+++ b/common/src/main/resources/assets/minecraft/shaders/core/gsr.json	(revision a1131575d6931b12d3cb0b9f8a519b861bc5ca4c)
@@ -0,0 +1,23 @@
+{
+  "blend": {
+    "func": "add",
+    "srcrgb": "srcalpha",
+    "dstrgb": "1-srcalpha"
+  },
+  "vertex": "passthrough",
+  "fragment": "gsr",
+  "attributes": ["Position", "UV0"],
+  "samplers": [
+    {
+      "name": "Sampler0"
+    }
+  ],
+  "uniforms": [
+    {
+      "name": "ViewportInfo",
+      "type": "float",
+      "count": 4,
+      "values": [0.0, 0.0, 1.0, 1.0]
+    }
+  ]
+}
Index: common/src/main/resources/assets/vivecraft/input/oculus_defaults.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/src/main/resources/assets/vivecraft/input/oculus_defaults.json b/common/src/main/resources/assets/vivecraft/input/oculus_defaults.json
--- a/common/src/main/resources/assets/vivecraft/input/oculus_defaults.json	(revision eaec65274edbf6dec8d28b76e7403b21c6b3145b)
+++ b/common/src/main/resources/assets/vivecraft/input/oculus_defaults.json	(revision a1131575d6931b12d3cb0b9f8a519b861bc5ca4c)
@@ -142,7 +142,7 @@
             }
           },
           "mode": "button",
-          "path": "/user/hand/left/input/y"
+          "path": "/user/hand/left/input/application_menu"
         },
         {
           "inputs": {
@@ -151,7 +151,7 @@
             }
           },
           "mode": "button",
-          "path": "/user/hand/left/input/x"
+          "path": "/user/hand/left/input/y"
         }
       ]
     },
@@ -243,7 +243,7 @@
             }
           },
           "mode": "button",
-          "path": "/user/hand/left/input/trigger"
+          "path": "/user/hand/left/input/x"
         },
         {
           "inputs": {
@@ -261,46 +261,52 @@
             }
           },
           "mode": "button",
-          "path": "/user/hand/right/input/a"
+          "path": "/user/hand/left/input/trigger"
         },
         {
           "inputs": {
             "click": {
               "output": "/actions/ingame/in/key.jump"
+            }
+               },
+               "mode" : "button",
+               "path" : "/user/hand/right/input/a"
             },
-            "position": {
-              "output": "/actions/ingame/in/vivecraft.key.freemovestrafe"
-            }
-          },
-          "mode": "joystick",
-          "path": "/user/hand/left/input/joystick"
-        },
-        {
-          "inputs": {
-            "position": {
-              "output": "/actions/ingame/in/vivecraft.key.rotateaxis"
-            }
-          },
-          "mode": "joystick",
-          "path": "/user/hand/right/input/joystick"
-        },
-        {
-          "inputs": {
-            "click": {
-              "output": "/actions/ingame/in/key.sneak"
-            }
-          },
-          "mode": "toggle_button",
-          "path": "/user/hand/right/input/joystick"
-        },
-        {
-          "inputs": {
-            "pull": {
+            {
+               "inputs" : {
+                  "position" : {
+                     "output" : "/actions/ingame/in/vivecraft.key.freemovestrafe"
+                  }
+               },
+               "mode" : "joystick",
+               "path" : "/user/hand/left/input/joystick"
+            },
+            {
+               "inputs" : {
+                  "position" : {
+                     "output" : "/actions/ingame/in/vivecraft.key.rotateaxis"
+                  }
+               },
+               "mode" : "joystick",
+               "path" : "/user/hand/right/input/joystick"
+            },
+            {
+               "inputs" : {
+                  "click" : {
+                     "output" : "/actions/ingame/in/key.sneak"
+                  }
+               },
+               "mode" : "toggle_button",
+               "path" : "/user/hand/right/input/joystick"
+            },
+            {
+               "inputs" : {
+                  "click": {
               "output": "/actions/ingame/in/vivecraft.key.teleportfallback"
             }
           },
-          "mode": "trigger",
-          "path": "/user/hand/left/input/trigger"
+          "mode": "button",
+          "path": "/user/hand/left/input/x"
         }
       ]
     },
Index: common/src/main/resources/assets/vivecraft/input/vive_defaults.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/src/main/resources/assets/vivecraft/input/vive_defaults.json b/common/src/main/resources/assets/vivecraft/input/vive_defaults.json
--- a/common/src/main/resources/assets/vivecraft/input/vive_defaults.json	(revision eaec65274edbf6dec8d28b76e7403b21c6b3145b)
+++ b/common/src/main/resources/assets/vivecraft/input/vive_defaults.json	(revision a1131575d6931b12d3cb0b9f8a519b861bc5ca4c)
@@ -146,15 +146,12 @@
         },
         {
           "inputs": {
-            "north": {
+            "click": {
               "output": "/actions/global/in/key.inventory"
             }
           },
-          "mode": "dpad",
-          "parameters": {
-            "sub_mode": "click"
-          },
-          "path": "/user/hand/right/input/trackpad"
+          "mode": "button",
+          "path": "/user/hand/left/input/y"
         }
       ]
     },
@@ -194,7 +191,7 @@
             }
           },
           "mode": "button",
-          "path": "/user/hand/right/input/trackpad"
+          "path": "/user/hand/right/input/a"
         },
         {
           "inputs": {
@@ -202,11 +199,11 @@
               "output": "/actions/gui/in/vivecraft.key.guiscrollaxis"
             }
           },
-          "parameters": {
-            "discrete_scroll_trackpad_slideandhold_enabled": "false"
-          },
-          "mode": "scroll",
-          "path": "/user/hand/right/input/trackpad"
+          "mode" : "scroll",
+               "parameters" : {
+                  "scroll_mode" : "discrete"
+          },
+          "path": "/user/hand/right/input/joystick"
         }
       ]
     },
@@ -223,36 +220,30 @@
         },
         {
           "inputs": {
-            "pull": {
-              "output": "/actions/ingame/in/vivecraft.key.teleportfallback"
+            "click": {
+              "output": "/actions/ingame/in/vivecraft.key.hotbarnext"
             }
           },
-          "mode": "trigger",
-          "path": "/user/hand/left/input/trigger"
+          "mode": "button",
+          "path": "/user/hand/right/input/grip"
         },
         {
           "inputs": {
-            "north": {
-              "output": "/actions/ingame/in/key.jump"
-            },
-            "south": {
-              "output": "/actions/ingame/in/key.sneak"
-            }
-          },
-          "mode": "dpad",
-          "parameters": {
-            "sub_mode": "click"
-          },
-          "path": "/user/hand/left/input/trackpad"
-        },
-        {
-          "inputs": {
+            "click": {
+              "output": "/actions/ingame/in/key.attack"
+                  }
+               },
+               "mode" : "button",
+               "path" : "/user/hand/right/input/trigger"
+            },
+            {
+               "inputs" : {
             "click": {
-              "output": "/actions/ingame/in/vivecraft.key.hotbarnext"
+              "output": "/actions/ingame/in/vivecraft.key.teleport"
             }
           },
           "mode": "button",
-          "path": "/user/hand/right/input/grip"
+          "path": "/user/hand/left/input/x"
         },
         {
           "inputs": {
@@ -261,42 +252,66 @@
             }
           },
           "mode": "button",
-          "path": "/user/hand/right/input/application_menu"
+          "path": "/user/hand/right/input/b"
         },
         {
           "inputs": {
             "click": {
-              "output": "/actions/ingame/in/key.attack"
+              "output": "/actions/ingame/in/key.use"
             }
           },
           "mode": "button",
-          "path": "/user/hand/right/input/trigger"
+          "path": "/user/hand/left/input/trigger"
         },
         {
           "inputs": {
-            "south": {
-              "output": "/actions/ingame/in/key.use"
+            "click": {
+              "output": "/actions/ingame/in/key.jump"
             }
           },
-          "mode": "dpad",
-          "parameters": {
-            "sub_mode": "click"
+          "mode": "button",
+          "path": "/user/hand/right/input/a"
+        },
+        {
+          "inputs": {
+            "position": {
+              "output": "/actions/ingame/in/vivecraft.key.freemovestrafe"
+            }
           },
-          "path": "/user/hand/right/input/trackpad"
+          "mode": "joystick",
+          "path": "/user/hand/left/input/joystick"
         },
         {
           "inputs": {
+            "position": {
+              "output": "/actions/ingame/in/vivecraft.key.rotateaxis"
+            }
+          },
+          "mode": "joystick",
+          "path": "/user/hand/right/input/joystick"
+            },
+            {
+               "inputs" : {
+                  "click" : {
+                     "output" : "/actions/ingame/in/key.sneak"
+            }
+          },
+          "mode": "toggle_button",
+          "path": "/user/hand/right/input/joystick"
+        },
+        {
+          "inputs": {
             "click": {
-              "output": "/actions/ingame/in/vivecraft.key.teleport"
+              "output": "/actions/ingame/in/vivecraft.key.teleportfallback"
             }
           },
           "mode": "button",
-          "path": "/user/hand/left/input/trigger"
-        }
-      ]
-    },
-    "/actions/keyboard": {
-      "sources": [
+          "path": "/user/hand/left/input/x"
+            }
+         ]
+      },
+      "/actions/keyboard" : {
+         "sources" : [
         {
           "inputs": {
             "click": {
@@ -315,9 +330,9 @@
           "mode": "button",
           "path": "/user/hand/right/input/grip"
         },
-        {
-          "inputs": {
-            "click": {
+            {
+               "inputs" : {
+                  "click": {
               "output": "/actions/keyboard/in/vivecraft.key.keyboardclick"
             }
           },
@@ -334,34 +349,12 @@
           "path": "/user/hand/right/input/trigger"
         }
       ]
-    },
-    "/actions/technical": {
-      "sources": [
-        {
-          "inputs": {
-            "touch": {
-              "output": "/actions/technical/in/vivecraft.key.trackpadtouch"
-            }
-          },
-          "mode": "trackpad",
-          "path": "/user/hand/left/input/trackpad"
-        },
-        {
-          "inputs": {
-            "touch": {
-              "output": "/actions/technical/in/vivecraft.key.trackpadtouch"
-            }
-          },
-          "mode": "trackpad",
-          "path": "/user/hand/right/input/trackpad"
-        }
-      ]
     }
   },
   "category": "steamvr_input",
-  "controller_type": "vive_controller",
+  "controller_type": "oculus_touch",
   "description": "",
-  "name": "Vive Controller Defaults",
+  "name": "Oculus Touch Defaults",
   "options": {},
   "simulated_actions": []
 }
Index: common/src/main/resources/assets/vivecraft/lang/en_us.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/src/main/resources/assets/vivecraft/lang/en_us.json b/common/src/main/resources/assets/vivecraft/lang/en_us.json
--- a/common/src/main/resources/assets/vivecraft/lang/en_us.json	(revision eaec65274edbf6dec8d28b76e7403b21c6b3145b)
+++ b/common/src/main/resources/assets/vivecraft/lang/en_us.json	(revision a1131575d6931b12d3cb0b9f8a519b861bc5ca4c)
@@ -188,6 +188,7 @@
   "vivecraft.options.MIXED_REALITY_RENDER_CAMERA_MODEL": "Show Camera Model",
   "vivecraft.options.PHYSICAL_KEYBOARD_THEME": "Keyboard Theme",
   "vivecraft.options.KEYBOARD_PRESS_BINDS": "Keyboard Presses Bindings",
+  "vivecraft.options.STEREOPLUGIN": "Stereo Plugin",
   "_comment6": "Option tooltips",
   "vivecraft.options.HUD_SCALE.tooltip": "Relative size HUD takes up in field-of-view.\nThe units are just relative, not in degrees or a fraction of FOV or anything.",
   "vivecraft.options.HUD_DISTANCE.tooltip": "Distance the floating HUD is drawn in front of your body.\nThe relative size of the HUD is unchanged by this.\nDistance is in meters (though isn't obstructed by blocks).",
@@ -354,6 +355,9 @@
   "vivecraft.options.keyboardtheme.aesthetic": "bAdebsdtbhdebtdibc",
   "vivecraft.options.keyboardtheme.dose": "Medicine",
   "vivecraft.options.keyboardtheme.custom": "Custom",
+  "vivecraft.options.vrprovider.openvr": "OpenVR",
+  "vivecraft.options.vrprovider.openxr": "OpenXR",
+  "vivecraft.options.vrprovider.nullvr": "NullVR",
   "_comment8": "Button text",
   "vivecraft.gui.ok": "OK",
   "vivecraft.gui.clear": "Clear",
Index: common/src/main/resources/vivecraft.accesswidener
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/src/main/resources/vivecraft.accesswidener b/common/src/main/resources/vivecraft.accesswidener
--- a/common/src/main/resources/vivecraft.accesswidener	(revision eaec65274edbf6dec8d28b76e7403b21c6b3145b)
+++ b/common/src/main/resources/vivecraft.accesswidener	(revision a1131575d6931b12d3cb0b9f8a519b861bc5ca4c)
@@ -6,6 +6,8 @@
 accessible field net/minecraft/client/model/geom/ModelPart cubes Ljava/util/List;
 accessible field net/minecraft/client/model/geom/ModelPart$Cube polygons [Lnet/minecraft/client/model/geom/ModelPart$Polygon;
 
+accessible class com/mojang/blaze3d/systems/RenderSystem$AutoStorageIndexBuffer$IndexGenerator
+
 # custom player modle rendering
 accessible field net/minecraft/client/model/PlayerModel slim Z
 extendable method net/minecraft/client/renderer/entity/player/PlayerRenderer setModelProperties (Lnet/minecraft/client/player/AbstractClientPlayer;)V
Index: common/src/main/resources/vivecraft.mixins.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/src/main/resources/vivecraft.mixins.json b/common/src/main/resources/vivecraft.mixins.json
--- a/common/src/main/resources/vivecraft.mixins.json	(revision eaec65274edbf6dec8d28b76e7403b21c6b3145b)
+++ b/common/src/main/resources/vivecraft.mixins.json	(revision a1131575d6931b12d3cb0b9f8a519b861bc5ca4c)
@@ -27,6 +27,7 @@
     "client_vr.KeyboardInputVRMixin",
     "client_vr.MinecraftVRMixin",
     "client_vr.MouseHandlerVRMixin",
+    "client_vr.OpenVRMixin",
     "client_vr.OptionsVRMixin",
     "client_vr.blaze3d.audio.LibraryVRMixin",
     "client_vr.blaze3d.platform.GlStateManagerVRMixin",
Index: fabric/build.gradle
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/fabric/build.gradle b/fabric/build.gradle
--- a/fabric/build.gradle	(revision eaec65274edbf6dec8d28b76e7403b21c6b3145b)
+++ b/fabric/build.gradle	(revision a1131575d6931b12d3cb0b9f8a519b861bc5ca4c)
@@ -63,9 +63,13 @@
     include(implementation('com.electronwill.night-config:core:3.6.6'))
 
     include(implementation("org.lwjgl:lwjgl-openvr:3.3.2"))
-    include(implementation("org.lwjgl:lwjgl-openvr:3.3.2:natives-linux"))
-    include(implementation("org.lwjgl:lwjgl-openvr:3.3.2:natives-macos"))
-    include(implementation("org.lwjgl:lwjgl-openvr:3.3.2:natives-windows"))
+    // include(implementation("org.lwjgl:lwjgl-openvr:3.2.2:natives-linux"))
+    // include(implementation("org.lwjgl:lwjgl-openvr:3.2.2:natives-macos"))
+    // include(implementation("org.lwjgl:lwjgl-openvr:3.2.2:natives-windows"))
+
+    include(implementation("org.lwjgl:lwjgl-openxr:3.3.2"))
+    // include(implementation("org.lwjgl:lwjgl-openxr:3.3.2:natives-linux"))
+    // include(implementation("org.lwjgl:lwjgl-openxr:3.3.2:natives-windows"))
 
 }
 
Index: forge/build.gradle
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/forge/build.gradle b/forge/build.gradle
--- a/forge/build.gradle	(revision eaec65274edbf6dec8d28b76e7403b21c6b3145b)
+++ b/forge/build.gradle	(revision a1131575d6931b12d3cb0b9f8a519b861bc5ca4c)
@@ -60,11 +60,19 @@
     forgeRuntimeLibrary("org.lwjgl:lwjgl-openvr:3.3.2:natives-macos")
     forgeRuntimeLibrary("org.lwjgl:lwjgl-openvr:3.3.2:natives-windows")
 
+    forgeRuntimeLibrary("org.lwjgl:lwjgl-openxr:3.3.1")
+    forgeRuntimeLibrary("org.lwjgl:lwjgl-openxr:3.3.1:natives-linux")
+    forgeRuntimeLibrary("org.lwjgl:lwjgl-openxr:3.3.1:natives-windows")
+
     // shadow the natives
     bundle("org.lwjgl:lwjgl-openvr:3.3.1") { transitive = false }
     bundle("org.lwjgl:lwjgl-openvr:3.3.1:natives-linux") { transitive = false }
     bundle("org.lwjgl:lwjgl-openvr:3.3.1:natives-macos") { transitive = false }
     bundle("org.lwjgl:lwjgl-openvr:3.3.1:natives-windows") { transitive = false }
+
+    bundle("org.lwjgl:lwjgl-openxr:3.3.1") { transitive = false }
+    bundle("org.lwjgl:lwjgl-openxr:3.3.1:natives-linux") { transitive = false }
+    bundle("org.lwjgl:lwjgl-openxr:3.3.1:natives-windows") { transitive = false }
 }
 
 processResources {
Index: neoforge/build.gradle
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/neoforge/build.gradle b/neoforge/build.gradle
--- a/neoforge/build.gradle	(revision eaec65274edbf6dec8d28b76e7403b21c6b3145b)
+++ b/neoforge/build.gradle	(revision a1131575d6931b12d3cb0b9f8a519b861bc5ca4c)
@@ -40,6 +40,10 @@
     bundle("org.lwjgl:lwjgl-openvr:3.3.2:natives-linux") { transitive = false }
     bundle("org.lwjgl:lwjgl-openvr:3.3.2:natives-macos") { transitive = false }
     bundle("org.lwjgl:lwjgl-openvr:3.3.2:natives-windows") { transitive = false }
+
+    bundle("org.lwjgl:lwjgl-openxr:3.3.1") { transitive = false }
+    bundle("org.lwjgl:lwjgl-openxr:3.3.1:natives-linux") { transitive = false }
+    bundle("org.lwjgl:lwjgl-openxr:3.3.1:natives-windows") { transitive = false }
 }
 
 processResources {
